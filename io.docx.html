<p>Portable Systems Group</p>
<p>Windows NT I/O System Specification</p>
<p><strong>Author:</strong> Darryl E. Havens</p>
<p>Revision 1.7, May 1, 1995</p>
<p>Update to include opening device for FILE_READ_ATTRIBUTES</p>
<p>Make sure operations after rename don't work like after delete</p>
<p>New device types - e</p>
<p>DEVICETYPE -&gt; DEVICE_TYPE</p>
<p>NtReadTerminalFile went away</p>
<p>Remove ErrorPort from create/open</p>
<p>Remove SourceProcess/TargetProcess from read/write</p>
<p>Add description of no ByteOffset to read/write if async I/O</p>
<p>Add FileFsAttributeInformation</p>
<p>Fix descriptions of _DIRECTORY option flags</p>
<p>Fix description of rename in general - from name to rename info</p>
<p>Add documentation for root directory relative rename</p>
<p>1. Introduction</p>
<p>2. Overview</p>
<p>3. User APIs</p>
<p>3.1 Create/Open File/Device Services</p>
<p>3.1.1 Creating and Opening Files</p>
<p>3.1.2 Opening Files</p>
<p>3.2 File Data Services</p>
<p>3.2.1 Reading Files</p>
<p>3.2.2 Writing Files</p>
<p>3.3 Directory Manipulation Services</p>
<p>3.3.1 Enumerating Files in a Directory</p>
<p>3.3.2 Enumerating Files in an Ole Directory File</p>
<p>3.3.3 Monitoring Directory Modifications</p>
<p>3.4 File Services</p>
<p>3.4.1 Obtaining Information about a File</p>
<p>3.4.2 Changing Information about a File</p>
<p>3.4.3 Obtaining Extended Attributes for a File</p>
<p>3.4.4 Changing Extended Attributes for a File</p>
<p>3.4.5 Locking Byte Ranges in Files</p>
<p>3.4.6 Unlocking Byte Ranges in Files</p>
<p>3.5 File System Services</p>
<p>3.5.1 Obtaining Information about a File System Volume</p>
<p>3.5.2 Changing Information about a File System Volume</p>
<p>3.5.3 Obtaining Quota Information about a File System Volume</p>
<p>3.5.4 Changing Quota Information about a File System Volume</p>
<p>3.5.5 Controlling File Systems</p>
<p>3.6 Miscellaneous Services</p>
<p>3.6.1 Flushing File Buffers</p>
<p>3.6.2 Canceling Pending I/O on a File</p>
<p>3.6.3 Miscellaneous I/O Control</p>
<p>3.6.4 Deleting a File</p>
<p>3.6.5 Querying the Attributes of a File</p>
<p>3.7 I/O Completion Objects</p>
<p>3.7.1 Creating/Opening I/O Completion Objects</p>
<p>3.7.2 Operating on I/O Completion Objects</p>
<p>4. Naming Conventions</p>
<p>5. Appendix A - Time Field Changes</p>
<p>5.1 Last Access Time</p>
<p>5.2 Last Modify Time</p>
<p>5.3 Last Change Time</p>
<p>6. Revision History</p>
<h1 id="introduction">Introduction</h1>
<p>This specification describes the basic overall API for the I/O system
of the <strong>Windows NT</strong> operating system. The I/O system is
responsible for the management of all input and output operations in the
system and for presenting the remainder of the system with a uniform and
device-independent view of the various devices connected to the
system.</p>
<p>The I/O system provides an interface for the user to perform I/O to
various devices attached to the machine. The I/O operations in this API
provide the user with a rich set of primitives to manipulate files and
devices in such a way as to hide most of the particulars of how the
device actually works.</p>
<p>The I/O system also provides system programmers with the ability to
write their own device drivers for those devices that <strong>Windows
NT</strong> does not support as part of its regular SDK. This part of
the I/O system is documented in the <em>Windows NT Driver Model
Specification</em> and is beyond the scope of this specification.</p>
<p>This specification does not attempt to exhaustively enumerate all
error conditions that occur on all paths or indicate the errors that can
occur after calling an API.</p>
<h1 id="overview">Overview</h1>
<p>The user interface model that <strong>Windows NT</strong> uses for
I/O consists of several different routines that perform such operations
as Open, Read, Write, Close, etc. For other operations that are not
included in the general set of routines, there is an
<strong>NtDeviceIoControlFile</strong> service. This service allows
device-dependent information to be passed to and from the device in a
well structured manner. Likewise, the <strong>NtFsControlFile</strong>
service which allows file-system-dependent information to be passed to
and from the file system in a well structured manner.</p>
<p>The I/O system is designed to support both OS/2 and POSIX I/O
operations easily to provide source code compatibility with those
standards. This allows users familiar with those systems to continue to
program using those interfaces without having to learn a new I/O
programming model. The OS/2 and POSIX subsystems emulate the I/O
services on top of the <strong>Windows NT</strong> services.</p>
<p>To perform I/O operations in <strong>Windows NT</strong>, a <em>file
handle</em> must be specified. File handles are obtained by calling the
<strong>NtCreateFile</strong> or <strong>NtOpenFile</strong> services.
These services either create or open a file and return a handle to it.
Alternatively, they may open a device directly and return a handle to
the device. In each case the handle is still referred to as a "file
handle" throughout the description of the APIs in this
specification.</p>
<p>From the point of view of the object management system, a file is a
<em>persistent object</em>. That is, a <em>file object</em> is treated
like any other object in the system except that it remains intact across
system boots. Handles to file objects, and therefore devices (depending
on how the "file" was opened) are usable in the object system.</p>
<p>Some of the I/O interfaces in <strong>Windows NT</strong> are
synchronous and others are asynchronous. For the latter type, it is up
to the caller to wait for the I/O operation to complete. This may be
done in either an alertable or a non-alertable manner. A file object in
<strong>Windows NT</strong> is a waitable object and can therefore be
used to synchronize completion of an I/O operation on the file. When a
request is made to perform an operation on a file, the file object is
set to the Not-Signaled state. When the operation completes, the file
object is set to the Signaled state.</p>
<p>Each asynchronous I/O service also optionally accepts an event and/or
the address of an <em>Asynchronous Procedure Call</em>
<strong>(APC)</strong> to be executed when the operation completes. If
an event is specified, the system sets it to the Not-Signaled state when
the I/O operation is requested and sets it to the Signaled state when
the I/O operation completes. The system will not normally set both the
File object and the event to the Signaled state. That is, if an event is
specified, then the event should be used for I/O completion
synchronization; otherwise the file object handle should be used.</p>
<p>If an APC is specified, the procedure is invoked when the I/O
completes with a parameter that is also supplied to the service. The
procedure is also passed the address of the I/O status block discussed
below.</p>
<p>Likewise, it is also possible to synchronize the completion of I/O
operations through the use of <em>I/O Completion objects</em>. An I/O
Completion object may be associated with a file such that a pool of
threads may wait on the completion of all I/O associated with the
object.</p>
<p>All service calls include the address of an <em>I/O status
block</em>. This variable contains information about the success or
failure of the operation once the operation has been completed. This
allows the caller to determine the status of the operation once the file
object or the event has been set to the Signaled state, or the APC
routine has been invoked. Upon completion of the I/O operation the
variable may also contain more information that is
service-dependent.</p>
<p>It should be noted that performing multiple operations on a file at
the same time requires that each operation be synchronized. That is,
requesting two asynchronous reads from a file and then waiting on the
file object will not guarantee that both operations have completed. In
the same manner, using the same event to synchronize these two
operations will not work either. Each operation must have its own event
associated with it, or the caller must set up an APC which will be able
to distinguish between the completion of each request.</p>
<p>Using an I/O system design whose primary data movement operations can
be totally asynchronous makes writing faster programs easier. It frees
the programmer from inventing methods of passing I/O requests to another
thread to gain parallelism. This means that the main loop need not be
blocked or concerned with the completion of I/O operations until it
absolutely requires the requested data.</p>
<p>This particular design also allows servers and network servers to be
written so that it is not necessary to dedicate a thread in the server
to each request or to each client. Because the APC routine can be
executed any time the server thread is ready for it, a single server
thread can potentially perform I/O for an unlimited number of clients
using very few system resources.</p>
<p>Since all potentially long I/O operations are asynchronous, a thread
that is waiting on an I/O operation in an alertable manner may fall out
of the wait. This allows programs to be written so that rundown and
cleanup are much easier to control. Likewise, because the user has a
choice, programs can still be written to block in a non-alertable manner
and simply wait for the I/O operation to complete. More information on
alerts can be found in the <em>Windows NT Process Structure</em>
specification.</p>
<p>The <strong>Windows NT</strong> I/O system provides one optimization
that can be used to save extraneous system calls. If the request for an
operation is successfully queued to a driver for completion later, then
the return status from the service is <em>STATUS_PENDING</em>. However,
if the operation successfully completes before the service returns
because the driver immediately completed the operation, then a status of
<em>STATUS_SUCCESS</em> is returned.</p>
<p>It is also possible to write an application that ignores the fact
that the <strong>Windows NT</strong> I/O system is asynchronous by
specifying that all I/O calls for a particular file object be performed
synchronously. Further, the I/O operations are selectively alertable or
non-alertable. This option is requested when the file is opened or
created. If the I/O is being performed with alerts enabled, then it is
possible for the I/O operation to be interrupted by an alert to the
thread. It is also possible to specify that no alerts may be taken
during the I/O operation.</p>
<p>If an application is performing I/O to a file in an alertable manner,
then it must be written to be prepared for the I/O to fail because an
alert occurred or an APC was delivered. In either case the I/O operation
must be restarted by invoking the API again.</p>
<p>When the I/O system is performing synchronous I/O on a file object,
it also maintains a current file pointer context for the file. This file
pointer may be read or written using APIs provided by the I/O system.
Furthermore, they are automatically updated whenever the file is read or
written according to the number of bytes transferred. It is also
possible to set the file pointer context on the read or write
operation.</p>
<p>Performing synchronous I/O on a file object also means that the I/O
to the file is serialized. That is, if Thread A has issued an I/O
operation on a file and Thread B issues an I/O operation using the same
file object, then Thread B will wait (alertable or non-alertable,
depending on how the file was opened) until Thread A's I/O
completes.</p>
<p>All of these features help the user deal with the system and use it
to perform I/O the way that he wants to work. He can still take
advantage of APC routines, for example, even if he is performing
synchronous I/O. However, he doesn't have to if that isn't what he
needs.</p>
<p>In order to access a file or a device, the caller must have
permission to access the device in the requested manner. For example,
some devices are considered single user devices. This is accomplished
through the object management system in <strong>Windows NT</strong>. The
object that represents a device is called a <em>device object</em>.
Device objects may be created by device drivers using the <em>exclusive
attribute</em>. This attribute indicates that only one process may open
the object. Any other attempt to open a device from a process other than
the "owning" process will fail. This implies that it is possible for a
process to "own" a device. Of course, since handles can be inherited by
child processes, then children of the owning process may share the
device with the parent process.</p>
<p>A file or a device may specify an <em>Access Control List</em>
<strong>(ACL)</strong>. An ACL is a list of <em>Access Control
Entries</em> <strong>(ACEs)</strong> that specify what access rights a
user has to the file or device. The user must have the requested access
in order to successfully perform operations on the object.</p>
<p><strong>Windows NT</strong> also provides file sharing among threads
within a process and between processes. Because of the object
architecture design used in <strong>Windows NT</strong>, it is possible
for all of the threads within a process to access a file that one of the
threads "opened" by using the returned file handle. Furthermore, a
process that is created by one of the threads may also have access to
the file if the file object is opened so that its handle is
inheritable.</p>
<p>Finally, <strong>Windows NT</strong> provides file sharing by
allowing multiple processes to open the same file. A file can be opened
so that other processes may read, write, or perform both or neither
operation on the file.</p>
<h1 id="user-apis">User APIs</h1>
<p>The following sections present the user interface to the I/O
system.</p>
<h2 id="createopen-filedevice-services">Create/Open File/Device
Services</h2>
<p>When a user wishes to access a file or a device, he must create or
open it. This causes a handle to be returned that can then be used to
manipulate the file or device in subsequent calls.</p>
<p>File handles are closed via the generic <strong>NtClose</strong>
service. This service is discussed elsewhere in the <strong>Windows
NT</strong> documentation. It should be noted that, just like all other
system objects, a file is not actually deleted until all of the valid
handles to it are closed and no referenced pointers remain.</p>
<p>The user APIs that supports creating and opening files and opening
devices is as follows:</p>
<blockquote>
<p><strong>NtCreateFile -</strong> Create or open a file and return a
file handle.</p>
<p><strong>NtOpenFile -</strong> Open a file and return a file
handle.</p>
</blockquote>
<h3 id="creating-and-opening-files">Creating and Opening Files</h3>
<p>A file can be created or opened using the
<strong>NtCreateFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtCreateFile(</strong></p>
<blockquote>
<p><strong>OUT PHANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN ACCESS_MASK</strong> <em>DesiredAccess,</em></p>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>AllocationSize</em>
<strong>OPTIONAL</strong><em>,</em></p>
<p><strong>IN ULONG</strong> <em>FileAttributes,</em></p>
<p><strong>IN ULONG</strong> <em>ShareAccess,</em></p>
<p><strong>IN ULONG</strong> <em>CreateDisposition,</em></p>
<p><strong>IN ULONG</strong> <em>CreateOptions,</em></p>
<p><strong>IN PVOID</strong> <em>EaBuffer</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>EaLength</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A pointer to a variable that receives the file
handle value.</p>
<p><em>DesiredAccess</em> - Specifies the type of access that the caller
requires to the file.</p>
<p><strong><u>DesiredAccess Flags</u></strong></p>
<p><em>SYNCHRONIZE</em> - The file handle may be waited on to
synchronize with the completion of the I/O operation.</p>
<p><em>DELETE</em> - The file may be deleted.</p>
<p><em>READ_CONTROL</em> - The ACL and ownership information associated
with the file may be read.</p>
<p><em>WRITE_DAC</em> - The Discretionary ACL associated with the file
may be written.</p>
<p><em>WRITE_OWNER</em> - Ownership information associated with the file
may be written.</p>
<p><em>FILE_READ_DATA</em> - Data may be read from the file.</p>
<p><em>FILE_WRITE_DATA</em> - Data may be written to the file.</p>
<p><em>FILE_EXECUTE</em> - Data may be faulted into memory from the file
via paging I/O.</p>
<p><em>FILE_APPEND_DATA</em> - Data may only be appended to the
file.</p>
<p><em>FILE_READ_ATTRIBUTES</em> - File attributes flags may be
read.</p>
<p><em>FILE_WRITE_ATTRIBUTES</em> - File attributes flags may be
written.</p>
<p><em>FILE_READ_EA</em> - Extended attributes associated with the file
may be read.</p>
<p><em>FILE_WRITE_EA</em> - Extended attributes associated with the file
may be written.</p>
<p>The three following values are the generic access types that the
caller may request. The mapping to specific access rights is given for
each:</p>
<p><em>GENERIC_READ</em> - Maps to <em>STANDARD_RIGHTS_READ,</em>
<em>FILE_READ_DATA, FILE_READ_ATTRIBUTES,</em> and
<em>FILE_READ_EA</em>.</p>
<p><em>GENERIC_WRITE</em> - Maps to <em>STANDARD_RIGHTS_WRITE,
FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA,</em> and
<em>FILE_APPEND_DATA</em>.</p>
<p><em>GENERIC_EXECUTE</em> - Maps to <em>STANDARD_RIGHTS_EXECUTE,
SYNCHRONIZE,</em> and <em>FILE_EXECUTE</em>.</p>
<p>For more information about the standard rights accesses, see the
<em>Windows NT Local Security Specification</em>.</p>
<p>If the file being created or opened is a directory file, as specified
in the <em>CreateOptions</em> argument, then the following types of
access may be requested:</p>
<p><em>FILE_LIST_DIRECTORY</em> - Files in the directory may be
listed.</p>
<p><em>FILE_TRAVERSE</em> - The directory may be traversed. That is, it
may be in the pathname of a file.</p>
<p><em>FILE_READ_DATA, FILE_WRITE_DATA, FILE_EXECUTE,</em> and
<em>FILE_APPEND_DATA</em> accesses are not valid when creating or
opening a directory file.</p>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of the file, a root directory, a security descriptor, a quality
of service descriptor, and a set of file object attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the file to be created or opened. This file specification must be a
fully qualified file specification or the name of a device, unless it is
a file relative to the directory specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the file
specified by the <em>ObjectName</em> field is a file specification
relative to the directory file supplied by this handle.</p>
<p><strong>PSECURITY_DESCRIPTOR</strong> <em>SecurityDescriptor</em> -
Optionally specifies the security descriptor that should be applied to
the file. The ACLs specified by the security descriptor are only applied
to the file if it is created. If not supplied and the file is created,
then the ACL placed on the file is file-system-dependent, but most file
systems propagate some part of the ACL from the parent directory file
combined with the caller's default ACL.</p>
<p><strong>PSECURITY_QUALITY_OF_SERVICE</strong>
<em>SecurityQualityOfService</em> - Specifies the access a server should
be given to the client's security context. This field is only used when
a connection to a protected server is established. It allows the caller
to control which parts of his security context are made available to the
server and whether or not the server may impersonate the caller.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_INHERIT</em> - Indicates that the handle to the file is to be
inherited by the new process when an <strong>NtCreateProcess</strong>
operation is performed to create a new process.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The actual action taken by
the system is written to the <em>Information</em> field of this
variable.</p>
<p><em>AllocationSize</em> - Optionally specifies the initial allocation
size of the file in bytes. The size has no effect unless the file is
created, overwritten, or superseded.</p>
<p><em>FileAttributes</em> - Specifies the file attributes for the file.
Any combination of flags is acceptable except that all other flags
override the normal file attribute, <em>FILE_ATTRIBUTE_NORMAL</em>. File
attributes are only applied to the file if it is created, superseded,
or, in some cases, overwritten. See the description in the text below
for more details.</p>
<p><strong><u>FileAttributes Flags</u></strong></p>
<p><em>FILE_ATTRIBUTE_NORMAL</em> - A normal file should be created.</p>
<p><em>FILE_ATTRIBUTE_READONLY</em> - A read-only file should be
created.</p>
<p><em>FILE_ATTRIBUTE_HIDDEN</em> - A hidden file should be created.</p>
<p><em>FILE_ATTRIBUTE_SYSTEM</em> - A system file should be created.</p>
<p><em>FILE_ATTRIBUTE_ARCHIVE</em> - The file should be marked so that
it will be archived.</p>
<p><em>FILE_ATTRIBUTE_TEMPORARY</em> - A temporary should be
created.</p>
<p><em>FILE_ATTRIBUTE_COMPRESSED</em> - A compressed file should be
created.</p>
<p><em>FILE_ATTRIBUTE_OFFLINE</em> - An off-line file should be
created.</p>
<p><em>ShareAccess</em> - Specifies the type of share access that the
caller would like to the file.</p>
<p><strong><u>ShareAccess Flags</u></strong></p>
<p><em>FILE_SHARE_READ</em> - Other open operations may be performed on
the file for read access.</p>
<p><em>FILE_SHARE_WRITE</em> - Other open operations may be performed on
the file for write access.</p>
<p><em>FILE_SHARE_DELETE</em> - Other open operations may be performed
on the file for delete access.</p>
<p><em>CreateDisposition</em> - Specifies the actions to be taken if the
file does or does not already exist.</p>
<p><strong><u>CreateDisposition Values</u></strong></p>
<p><em>FILE_SUPERSEDE</em> - Indicates that if the file already exists
then it should be superseded by the specified file. If it does not
already exist then it should be created.</p>
<p><em>FILE_CREATE</em> - Indicates that if the file already exists then
the operation should fail. If the file does not already exist then it
should be created.</p>
<p><em>FILE_OPEN</em> - Indicates that if the file already exists it
should be opened rather than creating a new file. If the file does not
already exist then the operation should fail.</p>
<p><em>FILE_OPEN_IF</em> - Indicates that if the file already exists, it
should be opened. If the file does not already exist then it should be
created.</p>
<p><em>FILE_OVERWRITE</em> - Indicates that if the file already exists
it should be opened and overwritten. If the file does not already exist
then the operation should fail.</p>
<p><em>FILE_OVERWRITE_IF</em> - Indicates that if the file already
exists it should be opened and overwritten. If the file does not already
exist then it should be created.</p>
<p><em>CreateOptions</em> - Specifies the options that should be used
when creating or opening the file.</p>
<p><strong><u>CreateOptions Flags</u></strong></p>
<p><em>FILE_DIRECTORY_FILE</em> - Indicates that the file being created
or opened is a directory file. The <em>CreateDisposition</em> parameter
must be set to one of <em>FILE_CREATE, FILE_OPEN,</em> or
<em>FILE_OPEN_IF.</em></p>
<p><em>FILE_NON_DIRECTORY_FILE</em> - Indicate that the file being
opened may not be a directory file.</p>
<p><em>FILE_WRITE_THROUGH</em> - Indicates that services that write data
to the file must actually write the data to the file before the
operation is considered to be complete.</p>
<p><em>FILE_SEQUENTIAL_ONLY</em> - Indicates that the file will only be
accessed sequentially.</p>
<p><em>FILE_RANDOM_ACCESS</em> - Indicates that the file will be
accessed randomly so no sequential read ahead operations should be
performed on the file.</p>
<p><em>FILE_NO_INTERMEDIATE_BUFFERING</em> - Indicates that no caching
or intermediate buffering is performed for the file.</p>
<p><em>FILE_SYNCHRONOUS_IO_ALERT</em> - Indicates that all operations on
the file are performed synchronously. Any wait being performed on behalf
of the caller is subject to premature termination from alerts. This flag
also causes the I/O system to maintain the file position context.</p>
<p><em>FILE_SYNCHRONOUS_IO_NONALERT</em> - Indicates that all operations
on the file are performed synchronously. Waits in the system to
synchronize I/O queueing and completion are not subject to alerts. This
flag also causes the I/O system to maintain the file position
context.</p>
<p><em>FILE_CREATE_TREE_CONNECTION</em> - Indicates that a tree
connection is to be created.</p>
<p><em>FILE_COMPLETE_IF_OPLOCKED</em> - Indicates that the operation
should complete immediately with an alternate success code if the target
file is oplocked rather than blocking the caller's thread.</p>
<p><em>FILE_NO_EA_KNOWLEDGE</em> - Indicates the if the EAs on an
existing file being opened indicate that the caller must understand EAs
to properly interpret the file, then the file open should fail because
the caller does not understand how to deal with EAs.</p>
<p><em>FILE_DELETE_ON_CLOSE</em> - Indicates that the file should be
deleted when the last handle to it is closed.</p>
<p><em>FILE_OPEN_BY_FILE_ID</em> - Indicates that the file name contains
the name of the device, and a 64-bit ID that is to be used to open the
file.</p>
<p><em>FILE_OPEN_FOR_BACKUP_INTENT</em> - Indicates that the file is
being opened for backup intent, hence, the system should check for
<strong>SeBackupPrivilege</strong> or
<strong>SeRestorePrivilege</strong> and grant the caller the appropriate
accesses to the file before checking the <em>DesiredAccess</em> against
the file's security descriptor.</p>
<p><em>FILE_TRANSACTED_MODE</em> - Indicates that the file is to be
opened in transacted mode. This specifies that no changes to the file
should be visible to other openers of the file until the transaction is
committed.</p>
<p><em>FILE_RESERVE_OPFILTER</em> - Indicates that a filter oplock
should be reserved on the file if possible. The first I/O operation on
the file must be an oplock request so that the caller can determine
whether or not the oplock was granted.</p>
<p><em>FILE_OPEN_OFFLINE_FILE</em> - Indicates that if the target file
has been moved from primary storage and the target file is an off-line
file, then the marker itself is to be opened rather than retrieving the
actual file.</p>
<p><em>FILE_STORAGE_TYPE_SPECIFIED</em> - Indicates that this
<em>CreateOptions</em> parameter specifies a storage type field.</p>
<p><em>FILE_STORAGE_TYPE_DEFAULT</em> - Create/open a file of default
storage type.</p>
<p><em>FILE_STORAGE_TYPE_DIRECTORY</em> - Create/open an enumerable
directory file.</p>
<p><em>FILE_STORAGE_TYPE_FILE</em> - Create/open normal data file.</p>
<p><em>FILE_STORAGE_TYPE_DOCFILE</em> - Create/open a document file.</p>
<p><em>FILE_STORAGE_TYPE_JUNCTION_POINT</em> - Create/open a junction
point.</p>
<p><em>FILE_STORAGE_TYPE_CATALOG</em> - Create/open a summary
catalogue.</p>
<p><em>FILE_STORAGE_TYPE_STRUCTURED_STORAGE</em> - Create/open
structured storage.</p>
<p><em>FILE_STORAGE_TYPE_EMBEDDING</em> - Create/open an embedding.</p>
<p><em>FILE_STORAGE_TYPE_STREAM</em> - Create/open an alternate data
stream on a file.</p>
<p><em>EaBuffer</em> - Optionally specifies a list of EAs that should be
set on the file if it is created. This is done as an atomic operation.
That is, if an error occurs setting the EAs on the file, then the file
will not be created.</p>
<p><em>EaLength</em> - Supplies the length of the <em>EaBuffer</em>. If
no buffer is supplied then this value should be zero.</p>
</blockquote>
<p>The I/O status block specified by the <em>IoStatusBlock</em>
parameter has the following type definition:</p>
<blockquote>
<p>typedef struct _IO_STATUS_BLOCK {</p>
<p>NTSTATUS Status;</p>
<p>ULONG Information;</p>
<p>} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>Status</strong> Final status of the operation</p>
<p><strong>Information</strong> Additional information about the
operation</p>
</blockquote>
<p>The <strong>NtCreateFile</strong> service either causes a new file
(or directory) to be created, or it opens an existing file or device.
The action taken is dependent on the name of the object being opened,
whether the object already existed, and the specified create disposition
value. A file handle is returned that can be used by subsequent service
calls to manipulate the file itself or the data within the file.</p>
<p>There are two basic ways to specify the name of the file that is to
be created/opened:</p>
<blockquote>
<p>o - A fully qualified pathname. This method simply supplies the full
file specification for the file. This is done using the
<em>ObjectName</em> field of the <em>ObjectAttributes</em> structure. No
<em>RootDirectory</em> handle may be specified.</p>
<p>o - A relative pathname. This method supplies the name of the file as
a relative pathname. The path is relative to the directory file
represented by the handle in the <em>RootDirectory</em> field of the
<em>ObjectAttributes</em> structure.</p>
</blockquote>
<p>Once the I/O operation is complete, the <em>Information</em> field of
the I/O status block contains information about the action actually
taken by the system. That is, one of <em>FILE_SUPERSEDED, FILE_CREATED,
FILE_OPENED,</em> or <em>FILE_OVERWRITTEN,</em> is returned in this
field.</p>
<p>The <em>SYNCHRONIZE</em> desired-access flag must be set in order for
the caller to wait on the file handle to synchronize I/O completion. If
this desired access is not specified, then I/O completion must be
synchronized through the use of an event or an APC routine.</p>
<p>If <em>FILE_EXECUTE</em> is the only desired-access flag specified
other than <em>SYNCHRONIZE</em>, then the caller cannot directly read or
write any data in the file using the returned file handle. All
operations on the file occur through the system pager in response to
instruction and data accesses.</p>
<p>If <em>FILE_APPEND_DATA</em> is the only desired-access flag
specified other than <em>SYNCHRONIZE</em>, then the caller can only
write to the end of the file. Any offset information on writes to the
file is ignored. The file will automatically be extended as necessary
for these types of write operations.</p>
<p>Specifying the <em>FILE_WRITE_DATA</em> desired-access flag for a
file also allows writes beyond the end of the file to occur. The file is
also automatically extended for these types of writes as well.</p>
<p>Files may be shared among threads within a process, or among a family
of processes through inheritance, by simply opening or creating the
file. The file handle can then be used to access the same file. Note
that the OBJ_INHERIT object attribute flag must be specified in the
<em>ObjectAttributes</em> parameter in order for sharing to occur
between parent and child processes through use of the file handle.</p>
<p>Access to a file may be shared among separate cooperating processes
or threads by requesting that the file system open the file for shared
access. This is accomplished through the flags in the
<em>ShareAccess</em> mode parameter. Provided that both file openers
have the privilege to access the file in the specified manner, the file
can be successfully opened and shared. If the caller does not specify
<em>FILE_SHARE_READ, FILE_SHARE_WRITE,</em> or
<em>FILE_SHARE_DELETE,</em> then no other open operations may be
performed on the file.</p>
<p>In order for the file to be successfully opened, the requested access
mode to the file must be compatible with the way in which other opens to
the file have been made. That is, the desired access mode to the file
must not conflict with the accesses that other openers of the file have
disallowed.</p>
<p>The <em>FILE_SUPERSEDE</em> disposition value specifies that if the
file does not already exist, it is to be created. If the file already
exists, then it should be superseded. Superseding a file requires that
the accessor have delete access to the existing file. That is, the
existing file is effectively deleted and then recreated. This implies
that if someone else already has the file open, they have specified that
the file may be deleted by another file opener. This is done by
specifying a <em>ShareAccess</em> parameter with the
<em>FILE_SHARE_DELETE</em> flag set. This type of disposition is
consistent with the Unix style of overwriting files.</p>
<p>The <em>FILE_OVERWRITE_IF</em> disposition value is much like the
<em>FILE_SUPERSEDE</em> disposition value. If the file exists, then it
will be overwritten; if it does not already exist then it will be
created. Overwriting a file is semantically equivalent to a supersede
operation except that it requires write access to the file rather than
delete access. That is, the requestor must have write access to the file
and if someone else already has the file open, they must have specified
that the file may be written by another file opener. This is done by
specifying a <em>ShareAccess</em> parameter with the
<em>FILE_SHARE_WRITE</em> flag set. Another difference between an
overwrite and a supersede is that the specified file attributes are
logically OR'd with those already on the file. That is, the caller may
not turn off any flags already set in the attributes but may turn others
on. This style of overwriting files is consistent with DOS and OS/2.</p>
<p>The <em>FILE_OVERWRITE</em> disposition value performs exactly the
same operation as a <em>FILE_OVERWRITE_IF</em>, except that if the file
does not already exist the operation will fail.</p>
<p>The <em>FILE_DIRECTORY_FILE</em> option specifies that the file to be
created or opened is a directory file. If this option is specified, then
the <em>CreateDisposition</em> parameter must be set to one of
<em>FILE_CREATE, FILE_OPEN,</em> or <em>FILE_OPEN_IF.</em> Likewise, the
only create options that may be specified are
<em>FILE_SYNCHRONOUS_IO_ALERT, FILE_SYNCHRONOUS_IO_NONALERT,
FILE_WRITE_THROUGH, FILE_OPEN_FOR_BACKUP_INTENT,</em> and
<em>FILE_OPEN_BY_FILE_ID.</em> When a directory file is created, the
file system creates an appropriate structure on the disk to represent an
empty directory for that particular file system's on-disk structure. If
this option was specified and the file being opened is not a directory
file, then the API will fail.</p>
<p>Conversely, the <em>FILE_NON_DIRECTORY_FILE</em> option specifies
that the target file being opened may not be a directory file. It must
be a data file, device, volume, etc., or the API is to fail.</p>
<p>It is also possible to further control the type of file, directory,
structured storage, etc. that one wishes to create or open by providing
the <em>FILE_STORAGE_TYPE_SPECIFIED</em> flag. This flag indicates that
one of the <em>FILE_STORAGE_TYPE_xxx</em> values has been supplied. Note
that specifying <em>FILE_DIRECTORY_FILE</em> is equivalent to specifying
<em>FILE_STORAGE_TYPE_SPECIFIED</em> and also specifying
<em>FILE_STORAGE_TYPE_DIRECTORY</em>. Likewise, specifying
<em>FILE_NON_DIRECTORY_FILE</em> is equivalent to specifying
<em>FILE_STORAGE_TYPE_SPECIFIED</em> and also specifying
<em>FILE_STORAGE_TYPE_FILE.</em></p>
<p>The <em>FILE_NO_INTERMEDIATE_BUFFER</em> option specifies that the
file system should not perform any intermediate buffering on behalf of
the caller. This causes several restrictions to be placed on the
caller's parameters to various service calls.</p>
<blockquote>
<p>o - The byte offset parameter to read and write operations must be an
integral number of 512-byte blocks.</p>
<p>o - The length of the read or write operation must be an integral
number of 512-byte blocks. Note that specifying a read operation to a
buffer whose length is 512 bytes may result in a smaller number of
significant bytes being transferred to the buffer because the end of the
file was reached, however, the driver may still be able to transfer a
whole sector of data directly to the buffer.</p>
<p>o - Buffers must be aligned to that of the device. The device
alignment requirement can be determined by querying the file.</p>
<p>o - Files opened for this type of access may not be opened for
<em>FILE_APPEND_DATA</em> access.</p>
<p>o - The <em>FILE_WRITE_THROUGH</em> option is automatically set when
intermediate buffering is disabled.</p>
<p>o - Calls to set the file position pointer for files opened in this
manner may only specify offsets wto 512-byte sector boundaries.</p>
</blockquote>
<p>The <em>FILE_SYNCHRONOUS_IO_ALERT</em> and
<em>FILE_SYNCHRONOUS_IO_NONALERT</em> create options allow the caller to
specify that all I/O operations on this file are to be performed
synchronously as long as they occur through the file object referred to
by the returned handle. The system also maintains the current "file
pointer context" for the file when the file is opened/created with
either of these options. Likewise, all I/O on the file will be
serialized across all threads and processes using the returned handle or
an inherited copy of the handle. The <em>SYNCHRONIZE</em> desired-access
flag must also be specified so that the I/O system can use the file
object as a synchronization object. Of course, these two options are
mutually exclusive.</p>
<p>These two options also imply that the I/O system maintain an internal
current file position pointer. This pointer can be used by the read and
write services. It can also be set or read by other APIs described later
in this document.</p>
<p>The <em>FILE_CREATE_TREE_CONNECTION</em> option specifies that a tree
connection to a remote node is to be created. For more information, see
the <em>Windows NT LAN Manager Software</em> specification.</p>
<p>The <em>FILE_COMPLETE_IF_OPLOCKED</em> option specifies that if the
target file is currently oplocked by another accessor of the file, that
the operation should complete immediately anyway without waiting for the
oplock break operation to be completed. The call to
<strong>NtCreateFile</strong> completes once the oplock break operation
has been started, rather than blocking the caller's thread waiting for
the break to complete. An alternate success code is returned to the
caller if an oplock break is in progress when the service completes.
This flag is mutually exclusive with the <em>FILE_RESERVE_OPFILTER</em>
flag. For more information on oplocks, see the <em>Windows NT
Opportunistic Locking Design Note</em>.</p>
<p>Setting the <em>FILE_TRANSACTED_MODE</em> option indicates that the
file system and Transaction Manager should work together to only allow
other openers of the file to see changes to the file when they are fully
committed. This means that other openers will not normally see any
writes to the file unless the data has actually been committed.</p>
<p>The <em>FILE_RESERVE_OPFILTER</em> option indicates that the caller
would like to reserve a filter oplock on the file, if possible. This
flag is mutually exclusive with the <em>FILE_COMPLETE_IF_OPLOCKED</em>
flag. The first I/O request issued on the file must be an oplock
<em>FSCTL</em> to determine whether or not the oplock was actually
reserved. For more information on oplocks, see the <em>Windows NT
Opportunistic Locking Design Note</em>.</p>
<p>A file is considered to have been moved from primary storage and a
marker left in its place if the target file’s
<em>FILE_ATTRIBUTE_OFFLINE</em> attribute bit is set. A normal attempt
to open such a file causes the HSM(s) in the system to attempt to
retrieve the original file. However, the marker itself can be opened by
specifying the <em>FILE_OPEN_OFFLINE_FILE</em> option.</p>
<p>If a list of EAs is supplied through specifying an <em>EaBuffer</em>,
then those EAs are applied to the file as an atomic operation. Note that
the EAs are only set on the file if the file is created (this also
includes supersede and overwrite operations). If setting the EAs on the
file incurs an error, then the file is not created, an appropriate error
is returned, and the <em>Information</em> field of the
<em>IoStatusBlock</em> variable is set to the offset into the EA buffer
of the EA that caused the error.</p>
<p>The type of the contents of the <em>EaBuffer</em> is
<em>FILE_FULL_EA_INFORMATION</em>. This type has the following
definition:</p>
<p>typedef struct _FILE_FULL_EA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>UCHAR Flags;</p>
<p>UCHAR EaNameLength;</p>
<p>USHORT EaValueLength;</p>
<p>CHAR EaName[];</p>
</blockquote>
<p>} FILE_FULL_EA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>Flags</strong> Flags to be associated with the EA</p>
<p><strong>EaNameLength</strong> Length of the EA’s name field,
excluding null termination character</p>
<p><strong>EaValueLength</strong> Length of the EA's value field</p>
<p><strong>EaName</strong> The name of the EA</p>
<p>The flags currently defined for EAs are:</p>
<p><strong>FILE_NEED_EA</strong>- This flag indicates that the caller
must understand EAs in order to understand the actual meaning or
representation of the file. Files who have an EA with this flag set
cannot be seen by callers attempting to access the file with the
<em>FILE_NO_EA_KNOWLEDGE</em> <em>CreateOption</em> set.</p>
<p>The value field begins after the end of the <em>EaName</em> field of
the structure, including a single null character. The
<em>EaNameLength</em> field does not include the null character in the
count Each entry in the list must be longword aligned. The
<em>NextEntryOffset</em> field specifies the number of bytes between the
current entry and the next entry in the buffer. If there are no more
entries following the current entry, then the value of this field is
zero.</p>
<p>For more information, refer to the <strong>NtSetEaFile</strong>
system service documented elsewhere in this specification.</p>
<h3 id="opening-files">Opening Files</h3>
<p>A file can be opened using the <strong>NtOpenFile</strong>
service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtOpenFile(</strong></p>
<blockquote>
<p><strong>OUT PHANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN ACCESS_MASK</strong> <em>DesiredAccess,</em></p>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN ULONG</strong> <em>ShareAccess,</em></p>
<p><strong>IN ULONG</strong> <em>OpenOptions</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A pointer to a variable that receives the file
handle value.</p>
<p><em>DesiredAccess</em> - Specifies the type of access that the caller
requires to the file.</p>
<p><strong><u>DesiredAccess Flags</u></strong></p>
<p><em>SYNCHRONIZE</em> - The file handle may be waited on to
synchronize with the completion of the I/O operation.</p>
<p><em>DELETE</em> - The file may be deleted.</p>
<p><em>READ_CONTROL</em> - The ACL and ownership information associated
with the file may be read.</p>
<p><em>WRITE_DAC</em> - The Discretionary ACL associated with the file
may be written.</p>
<p><em>WRITE_OWNER</em> - Ownership information associated with the file
may be written.</p>
<p><em>FILE_READ_DATA</em> - Data may be read from the file.</p>
<p><em>FILE_WRITE_DATA</em> - Data may be written to the file.</p>
<p><em>FILE_EXECUTE</em> - Data may be faulted into memory from the file
via paging I/O.</p>
<p><em>FILE_APPEND_DATA</em> - Data may only be appended to the
file.</p>
<p><em>FILE_READ_ATTRIBUTES</em> - File attributes flags may be
read.</p>
<p><em>FILE_WRITE_ATTRIBUTES</em> - File attributes flags may be
written.</p>
<p><em>FILE_READ_EA</em> - Extended attributes associated with the file
may be read.</p>
<p><em>FILE_WRITE_EA</em> - Extended attributes associated with the file
may be written.</p>
<p><em>FILE_LIST_DIRECTORY</em> - Files in the directory may be
listed.</p>
<p><em>FILE_TRAVERSE</em> - The directory may be traversed. That is, it
may be in the pathname of a file.</p>
<p>The three following values are the generic access types that the
caller may request. The mapping to specific access rights is given for
each:</p>
<p><em>GENERIC_READ</em> - Maps to <em>STANDARD_RIGHTS_READ,
FILE_READ_DATA, FILE_READ_ATTRIBUTES,</em> and
<em>FILE_READ_EA</em>.</p>
<p><em>GENERIC_WRITE</em> - Maps to <em>STANDARD_RIGHTS_WRITE,
FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA,</em> and
<em>FILE_APPEND_DATA</em>.</p>
<p><em>GENERIC_EXECUTE</em> - Maps to <em>STANDARD_RIGHTS_EXECUTE,
SYNCHRONIZE,</em> and <em>FILE_EXECUTE</em>.</p>
<p>For more information about standard rights accesses, see the
<em>Windows NT Local Security Specification</em>.</p>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of the file, a root directory, and a set of file object
attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the file to be opened. This file specification must be a fully qualified
file specification or the name of a device, unless it is a file relative
to the directory specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the file
specified by the <em>ObjectName</em> field is a file specification
relative to the directory file supplied by this handle.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_INHERIT</em> - Indicates that the handle to the file is to be
inherited by the new process when an <strong>NtCreateProcess</strong>
operation is performed to create a new process.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The actual action taken by
the system is written to the <em>Information</em> field of this
variable. For a more information on this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>ShareAccess</em> - Specifies the type of share access that the
caller would like to the file.</p>
<p><strong><u>ShareAccess Flags</u></strong></p>
<p><em>FILE_SHARE_READ</em> - Other open operations may be performed on
the file for read access.</p>
<p><em>FILE_SHARE_WRITE</em> - Other open operations may be performed on
the file for write access.</p>
<p><em>FILE_SHARE_DELETE</em> - Other open operations may be performed
on the file for delete access.</p>
<p><em>OpenOptions</em> - Specifies the options that should be used when
opening the file.</p>
<p><strong><u>OpenOptions Flags</u></strong></p>
<p><em>FILE_DIRECTORY_FILE</em> - Indicates that the file being opened
must be a directory file.</p>
<p><em>FILE_NON_DIRECTORY_FILE</em> - Indicate that the file being
opened may not be a directory file.</p>
<p><em>FILE_WRITE_THROUGH</em> - Indicates that services that write data
to the file must actually write the data to the file before the
operation is considered to be complete.</p>
<p><em>FILE_SEQUENTIAL_ONLY</em> - Indicates that the file will only be
accessed sequentially.</p>
<p><em>FILE_RANDOM_ACCESS</em> - Indicates that the file will be access
randomly so no read ahead operations should ever be performed on the
file.</p>
<p><em>FILE_NO_INTERMEDIATE_BUFFERING</em> - Indicates that no caching
or intermediate buffering is performed for the file.</p>
<p><em>FILE_SYNCHRONOUS_IO_ALERT</em> - Indicates that all operations on
the file are performed synchronously. Any wait being performed on behalf
of the caller is subject to premature termination from alerts. This flag
also causes the I/O system to maintain the file position context.</p>
<p><em>FILE_SYNCHRONOUS_IO_NONALERT</em> - Indicates that all operations
on the file are performed synchronously. Waits in the system to
synchronize I/O queueing and completion are not subject to alerts. This
flag also causes the I/O system to maintain the file position
context.</p>
<p><em>FILE_COMPLETE_IF_OPLOCKED</em> - Indicates that the operation
should complete immediately with an alternate success code if the target
file is oplocked rather than blocking the caller's thread.</p>
<p><em>FILE_NO_EA_KNOWLEDGE</em> - Indicates that if the EAs on an
existing file being opened indicate that the caller must understand EAs
to properly interpret the file, then the file open should fail because
the caller does not understand how to deal with EAs.</p>
<p><em>FILE_DELETE_ON_CLOSE</em> - Indicates that the file should be
deleted when the last handle to it is closed.</p>
<p><em>FILE_OPEN_BY_FILE_ID</em> - Indicates that the file name contains
the name of the device, and a 64-bit ID that is to be used to open the
file.</p>
<p><em>FILE_OPEN_FOR_BACKUP_INTENT</em> - Indicates that the file is
being opened for backup intent, hence, the system should check for
<strong>SeBackupPrivilege</strong> or
<strong>SeRestorePrivilege</strong> and grant the caller the appropriate
accesses to the file before checking the <em>DesiredAccess</em> against
the file's security descriptor.</p>
<p><em>FILE_TRANSACTED_MODE</em> - Indicates that the file is to be
opened in transacted mode. This specifies that no changes to the file
should be visible to other openers of the file until the transaction is
committed.</p>
<p><em>FILE_RESERVE_OPFILTER</em> - Indicates that a filter oplock
should be reserved on the file if possible. The first I/O operation on
the file must be an oplock request so that the caller can determine
whether or not the oplock was granted.</p>
<p><em>FILE_OPEN_OFFLINE_FILE</em> - Indicates that if the target file
has been moved from primary storage and the target file is an off-line
file, then the marker itself is to be opened rather than retrieving the
actual file.</p>
<p><em>FILE_STORAGE_TYPE_SPECIFIED</em> - Indicates that this
<em>CreateOptions</em> parameter specifies a storage type field.</p>
<p><em>FILE_STORAGE_TYPE_DEFAULT</em> - Create/open a file of default
storage type.</p>
<p><em>FILE_STORAGE_TYPE_DIRECTORY</em> - Create/open an enumerable
directory file.</p>
<p><em>FILE_STORAGE_TYPE_FILE</em> - Create/open normal data file.</p>
<p><em>FILE_STORAGE_TYPE_DOCFILE</em> - Create/open a document file.</p>
<p><em>FILE_STORAGE_TYPE_JUNCTION_POINT</em> - Create/open a junction
point.</p>
<p><em>FILE_STORAGE_TYPE_CATALOG</em> - Create/open a summary
catalogue.</p>
<p><em>FILE_STORAGE_TYPE_STRUCTURED_STORAGE</em> - Create/open
structured storage.</p>
<p><em>FILE_STORAGE_TYPE_EMBEDDING</em> - Create/open an embedding.</p>
<p><em>FILE_STORAGE_TYPE_STREAM</em> - Create/open an alternate data
stream on a file.</p>
</blockquote>
<p>The <strong>NtOpenFile</strong> service opens an existing file or
device. A file handle is returned that can be used by subsequent service
calls to manipulate the file itself or the data within the file.</p>
<p>There are two basic ways to specify the name of the file that is to
be opened:</p>
<blockquote>
<p>o - A fully qualified pathname. This method simply supplies the full
file specification for the file to be opened. This is done using the
<em>ObjectName</em> field of the <em>ObjectAttributes</em> structure. No
<em>RootDirectory</em> handle may be specified.</p>
<p>o - A relative pathname. This method supplies the name of the file as
a relative pathname. The path is relative to the directory file
represented by the handle in the <em>RootDirectory</em> field of the
<em>ObjectAttributes</em> structure.</p>
</blockquote>
<p>Once the I/O operation is complete, the <em>Information</em> field of
the I/O status block contains information about the action taken by the
system. That is, the <em>Information</em> field will contain
<em>FILE_OPENED.</em></p>
<p>The <em>SYNCHRONIZE</em> desired-access flag must be set in order for
the caller to wait on the file handle to synchronize I/O completion. If
this desired access is not specified, then I/O completion must be
synchronized through the use of an event or an APC routine.</p>
<p>If <em>FILE_EXECUTE</em> is the only desired-access flag specified
other than <em>SYNCHRONIZE</em>, then the caller cannot directly read or
write any data in the file using the returned file handle. All
operations on the file occur through the system pager in response to
instruction and data accesses.</p>
<p>If <em>FILE_APPEND_DATA</em> is the only desired-access flag
specified other than <em>SYNCHRONIZE</em>, then the caller can only
write to the end of the file. Any offset information on writes to the
file is ignored. The file will automatically be extended as necessary
for these types of write operations.</p>
<p>Specifying the <em>FILE_WRITE_DATA</em> desired-access flag for a
file also allows writes beyond the end of the file to occur. The file is
also automatically extended for these types of writes as well.</p>
<p>Files may be shared among threads within a process, or among a family
of processes through inheritance, by simply opening or creating the
file. The file handle can then be used to access the same file. Note
that the OBJ_INHERIT object attribute flag must be specified in the
<em>ObjectAttributes</em> parameter in order for sharing to occur
between parent and child processes through use of the file handle.</p>
<p>Access to a file may be shared among separate cooperating processes
or threads by requesting that the file system open the file for shared
access. This is accomplished through the flags in the
<em>ShareAccess</em> mode parameter. Provided that both file openers
have the privilege to access the file in the specified manner, the file
can be successfully opened and shared. If the caller does not specify
<em>FILE_SHARE_READ,</em> <em>FILE_SHARE_WRITE,</em> or
<em>FILE_SHARE_DELETE,</em> then no other open operations may be
performed on the file.</p>
<p>In order for the file to be successfully opened, the requested access
mode to the file must be compatible with the way in which other opens to
the file have been made. That is, the desired access mode to the file
must not conflict with the accesses that other openers of the file have
disallowed.</p>
<p>The <em>FILE_DIRECTORY_FILE</em> flag specifies that the file being
opened must be a directory file or the service will fail. Likewise, the
<em>FILE_NON_DIRECTORY_FILE</em> flag specifies that the service will
fail if the file being opened is a directory file.</p>
<p>It is also possible to further control the type of file, directory,
structured storage, etc. that one wishes to create or open by providing
the <em>FILE_STORAGE_TYPE_SPECIFIED</em> flag. This flag indicates that
one of the <em>FILE_STORAGE_TYPE_xxx</em> values has been supplied. Note
that specifying <em>FILE_DIRECTORY_FILE</em> is equivalent to specifying
<em>FILE_STORAGE_TYPE_SPECIFIED</em> and also specifying
<em>FILE_STORAGE_TYPE_DIRECTORY</em>. Likewise, specifying
<em>FILE_NON_DIRECTORY_FILE</em> is equivalent to specifying
<em>FILE_STORAGE_TYPE_SPECIFIED</em> and also specifying
<em>FILE_STORAGE_TYPE_FILE.</em></p>
<p>The <em>FILE_NO_INTERMEDIATE_BUFFER</em> option specifies that the
file system should not perform any intermediate buffering on behalf of
the caller. This causes several restrictions to be placed on the
caller's parameters to various service calls.</p>
<blockquote>
<p>o - The byte offset parameter to read and write operations must be an
integral number of 512-byte blocks.</p>
<p>o - The length of the read or write operation must be an integral
number of 512-byte blocks. Note that specifying a read operation to a
buffer whose length is 512 bytes may result in a smaller number of
significant bytes being transferred to the buffer because the end of the
file was reached, however, the driver may still be able to transfer a
whole sector of data directly to the buffer.</p>
<p>o - Buffers must be aligned to that of the device. The device
alignment requirement can be determined by querying the file.</p>
<p>o - Files opened for this type of access may not be opened for
<em>FILE_APPEND_DATA</em> access.</p>
<p>o - The <em>FILE_WRITE_THROUGH</em> option is automatically set when
intermediate buffering is disabled.</p>
<p>o - Calls to set the file position pointer for files opened in this
manner may only specify offsets to 512-byte sector boundaries.</p>
<p>o - All opens of the file must either enable or disable this feature.
That is, no mixed opens are permitted.</p>
</blockquote>
<p>The <em>FILE_SYNCHRONOUS_IO_ALERT</em> and
<em>FILE_SYNCHRONOUS_IO_NONALERT</em> open options allow the caller to
specify that all I/O operations on this file are to be performed
synchronously as long as they occur through the file object referred to
by the returned handle. The system also maintains the current "file
pointer context" for the file when the file is opened with either of
these options. Likewise, all I/O on the file will be serialized across
all threads and processes using the returned handle or an inherited copy
of the handle. The <em>SYNCHRONIZE</em> desired access flag must also be
specified so that the I/O system can use the file object as a
synchronization object.</p>
<p>These two options also imply that the I/O system maintain an internal
current file position pointer. This pointer can be used by the read and
write services. It can also be set or read by other APIs described later
in this document.</p>
<p>The <em>FILE_COMPLETE_IF_OPLOCKED</em> option specifies that if the
target file is currently oplocked by another accessor of the file, that
the operation should complete immediately anyway without waiting for the
oplock break operation to be completed. The call to
<strong>NtOpenFile</strong> completes once the oplock break operation
has been started, rather than blocking the caller's thread waiting for
the break to complete. An alternate success code is returned to the
caller if an oplock break is in progress when the service completes. For
more information on oplocks, see the <em>Windows NT Opportunistic
Locking Design Note</em>.</p>
<p>Setting the <em>FILE_TRANSACTED_MODE</em> option indicates that the
file system and Transaction Manager should work together to only allow
other openers of the file to see changes to the file when they are fully
committed. This means that other openers will not normally see any
writes to the file unless the data has actually been committed.</p>
<p>The <em>FILE_RESERVE_OPFILTER</em> option indicates that the caller
would like to reserve a filter oplock on the file, if possible. The
first I/O request issued on the file must be an oplock <em>FSCTL</em> to
determine whether or not the oplock was actually reserved. For more
information on oplocks, see the <em>Windows NT Opportunistic Locking
Design Note</em>.</p>
<p>A file is considered to have been moved from primary storage and a
marker left in its place if the target file’s
<em>FILE_ATTRIBUTE_OFFLINE</em> attribute bit is set. A normal attempt
to open such a file causes the HSM(s) in the system to attempt to
retrieve the original file. However, the marker itself can be opened by
specifying the <em>FILE_OPEN_OFFLINE_FILE</em> option.</p>
<h2 id="file-data-services">File Data Services</h2>
<p>This section presents those services that read data from and write
data to files. They provide the functionality to perform I/O to files
according to the options provided in the open/create services.</p>
<p>The APIs that support reading and writing files are as follows:</p>
<blockquote>
<p><strong>NtReadFile</strong> - Read data from a file into a specified
buffer.</p>
<p><strong>NtWriteFile</strong> - Write data to a file from a specified
buffer.</p>
</blockquote>
<h3 id="reading-files">Reading Files</h3>
<p>Data can be read from a file with the <strong>NtReadFile</strong>
service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtReadFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>Buffer,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>ByteOffset</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PULONG</strong> <em>Key</em> <strong>OPTIONAL</strong></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to the file to read.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The number of bytes actually
read from the file is returned in the <em>Information</em> field of this
variable. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>Buffer</em> - A pointer to a buffer to receive the bytes read
from the file.</p>
<p><em>Length</em> - The length of the specified <em>Buffer</em> in
bytes. This is the number of bytes that are read from the file unless
the end of the file is reached.</p>
<p><em>ByteOffset</em> - Supplies the starting byte offset within the
file where the read begins. An error is returned if an attempt is made
to start the read beyond the end of the file.</p>
<p>See the note below about the semantics of this parameter if the I/O
system is maintaining the current file pointer position.</p>
<p><em>Key</em> - Optionally specifies a <em>Key</em> that is used to
indicate the owner of a byte-range lock. If the value of the
<em>Key</em> and other conditions are met, then the locked range is
read.</p>
</blockquote>
<p>The routine specified by the <em>ApcRoutine</em> parameter has the
following type definition:</p>
<p><strong>typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(*PIO_APC_ROUTINE) (</strong></p>
<blockquote>
<p><strong>IN PVOID</strong> <em>ApcContext,</em></p>
<p><strong>IN PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>ApcContext</em> - This parameter is the value of
<em>ApcContext</em> in the call to the I/O system service.</p>
<p><em>IoStatusBlock</em> - This parameter is the pointer
<em>IoStatusBlock</em> passed in the call to the I/O system service.</p>
</blockquote>
<p>The <strong>NtReadFile</strong> service begins reading from the
<em>ByteOffset</em> byte within the file into the specified
<em>Buffer</em>. The read terminates under one of the following
conditions:</p>
<blockquote>
<p>o - The buffer is full. The number of bytes specified by the
<em>Length</em> parameter has been read. Therefore, no more data can be
placed into the buffer without an overflow.</p>
<p>o - During the read operation the end of the file is reached. There
is no more data in the file to be placed into the buffer.</p>
</blockquote>
<p>If the file was opened or created without intermediate buffering by
the file system, there are several restrictions on the parameters
supplied to this service. See the descriptions of the
<strong>NtCreateFile</strong> and <strong>NtOpenFile</strong> services
for more information.</p>
<p>If <em>FILE_SYNCHRONOUS_IO_ALERT</em> or
<em>FILE_SYNCHRONOUS_IO_NONALERT</em> are specified as options when the
file is opened/created, then the I/O system maintains the current file
position for the file. The caller may specify that the current file
pointer position be used instead of a specific byte offset within the
file in one of two ways:</p>
<blockquote>
<p>o - Specifying a <em>ByteOffset</em> parameter whose value is
<em>FILE_USE_FILE_POINTER_POSITION</em> rather than an actual byte
offset within the file.</p>
<p>o - Not specifying the <em>ByteOffset</em> parameter at all.</p>
</blockquote>
<p>Either of these methods causes the read to occur from the byte offset
within the file according to the value of the current file pointer
position. Once the read is complete, the pointer position is updated
according to the number of bytes that were read from the file.</p>
<p>If the current file position is being maintained by the I/O system,
then the caller may still read directly from a location in the file.
This automatically changes the current file position to point to that
position, performs the read, and then updates the position according to
the number of bytes actually read. This gives the caller an atomic "seek
and read" service. This is done by supplying the actual byte offset
within the file to be read.</p>
<p>The <em>Key</em> parameter can optionally be used to specify a key
value that is used to determine whether a locked range of bytes can be
read by the caller. That is, locked ranges of bytes have a key
associated with them using the <strong>NtLockFile</strong> system
service. The <em>Key</em> parameter is one of the values that must
exactly match the key associated with the lock in order to read the
locked range of bytes. More information can be found later in this
specification on byte range locking.</p>
<p>The <strong>NtReadFile</strong> service is also flexible enough to be
invoked for most read functions directly by an RPC stub routine that is
emulating a system service on behalf of an emulation subsystem. The OS/2
<strong>DosRead</strong> and POSIX <strong>read</strong> functions, for
example, can both be emulated by directly invoking this service.</p>
<p>This service requires <strong>FILE_READ_DATA</strong> access to the
file.</p>
<p>Once the data has been read, the <em>Event</em>, if specified, will
be set to the Signaled state. If no <em>Event</em> parameter was
specified, then the file object specified by the <em>FileHandle</em>
will be set to the Signaled state. If an <em>ApcRoutine</em> was
specified, it is invoked with the <em>ApcContext</em> and the address of
the <em>IoStatusBlock</em> as its arguments.</p>
<h3 id="writing-files">Writing Files</h3>
<p>Data can be written to a file with the <strong>NtWriteFile</strong>
service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtWriteFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PVOID</strong> <em>Buffer,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>ByteOffset</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PULONG</strong> <em>Key</em> <strong>OPTIONAL</strong></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to the file to write.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The number of bytes actually
written to the file is returned in the <em>Information</em> field of
this variable. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>Buffer</em> - A pointer to a buffer containing the data that
should be written to the file.</p>
<p><em>Length</em> - The number of bytes to write to the file from the
specified <em>Buffer</em>.</p>
<p><em>ByteOffset</em> - Supplies the starting byte offset within the
file where the write begins.</p>
<p>The notes below describe other valid values that this parameter can
express.</p>
<p><em>Key</em> - Optionally specifies a <em>Key</em> that it used to
indicate the owner of a byte range lock. If the value of the
<em>Key</em> and other conditions are met, then the locked range is
written.</p>
</blockquote>
<p>The <strong>NtWriteFile</strong> service begins writing
<em>Length</em> bytes from the specified <em>Buffer</em> to the byte
within the file specified by the <em>ByteOffset</em> parameter.</p>
<p>If the write occurs to a file beyond the current end of file mark,
then the file is automatically extended and the end of file mark is
updated. Any bytes not explicitly written between the old end of file
mark and the new end of file mark are defined to be zero.</p>
<p>If the file is opened with only <strong>FILE_APPEND_DATA</strong>
access, then the <em>ByteOffset</em> parameter is ignored. The data
contained in the <em>Buffer</em>, for <em>Length</em> bytes, is written
to the current end of the file.</p>
<p>If the file was opened or created without intermediate buffering by
the file system, there are several restrictions on the parameters
supplied to this service. See the descriptions of the
<strong>NtCreateFile</strong> and <strong>NtOpenFile</strong> services
for more information.</p>
<p>If <em>FILE_SYNCHRONOUS_IO_ALERT</em> or
<em>FILE_SYNCHRONOUS_IO_NONALERT</em> are specified when the file is
opened or created, then the I/O system maintains the current file
position pointer. The caller may specify that the current file pointer
position be used instead of a specific byte offset within the file in
one of two ways:</p>
<blockquote>
<p>o - Specifying a <em>ByteOffset</em> parameter whose value is
<em>FILE_USE_FILE_POINTER_POSITION</em> rather than an actual byte
offset within the file.</p>
<p>o - Not specifying the <em>ByteOffset</em> parameter at all.</p>
</blockquote>
<p>Either of these methods causes the write to occur from the byte
offset within the file according to the value of the current file
pointer position context. Once the write is complete, the pointer
position is updated according to the number of bytes that were written
to the file.</p>
<p>If the current file position is being maintained by the I/O system,
then the caller may still write directly to a location in the file. This
automatically changes the current file position to point to that
position, performs the write, and then updates the position according to
the number of bytes written. This gives the user an atomic "seek and
write" service. This is done by supplying the actual byte offset within
the file to be written.</p>
<p>It is also possible to cause the write to take place at the current
end of file. This can be done regardless of whether the I/O system is
maintaining file position information. Specifying a value of
<em>FILE_WRITE_TO_END_OF_FILE</em> for the <em>ByteOffset</em> parameter
causes this to occur.</p>
<p>The <em>Key</em> parameter can optionally be used to specify a key
value that determines whether a locked range of bytes can be written by
the caller. That is, locked ranges of bytes have a key associated with
them using the <strong>NtLockFile</strong> system service. The
<em>Key</em> parameter is one of the values that must exactly match the
lock specification associated with the lock in order to be able to write
the locked range of bytes. More information can be found later in this
specification on byte range locking.</p>
<p>The <strong>NtWriteFile</strong> service is also flexible enough to
be invoked for most write functions directly by an RPC stub routine
executing on behalf of an operating system emulation subsystem. The OS/2
<strong>DosWrite</strong> and POSIX <strong>write</strong> functions,
for example, can both be emulated by directly invoking these
services.</p>
<p>This service requires either <strong>FILE_WRITE_DATA</strong> or
<strong>FILE_APPEND_DATA</strong> access to the file. Note that having
only <strong>FILE_APPEND_DATA</strong> access to the file does not allow
the caller to write anywhere in the file except at the current end of
file mark, while having <strong>FILE_WRITE_DATA</strong> access to a
file does not preclude the caller from writing to or beyond the end of
the file.</p>
<p>Once the data has been written, the <em>Event</em>, if specified,
will be set to the Signaled state. If no <em>Event</em> parameter was
specified, then the file object specified by the <em>FileHandle</em>
will be set to the Signaled state. If an <em>ApcRoutine</em> was
specified, it is invoked with the <em>ApcContext</em> and the address of
the <em>IoStatusBlock</em> as its arguments.</p>
<h2 id="directory-manipulation-services">Directory Manipulation Services
</h2>
<p>This section presents those services that manipulate directories
within the file system.</p>
<p>The APIs that permit directory manipulation are as follows:</p>
<blockquote>
<p><strong>NtQueryDirectoryFile</strong> - Enumerate files within a
directory.</p>
<p><strong>NtNotifyChangeDirectoryFile</strong> - Monitor directory for
modifications.</p>
<p><strong>NtQueryOleDirectoryFile</strong> - Enumerate streams and
embeddings in the OLE name space.</p>
</blockquote>
<h3 id="enumerating-files-in-a-directory">Enumerating Files in a
Directory</h3>
<p>The files within a directory can be enumerated using the
<strong>NtQueryDirectoryFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryDirectoryFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>FileInformation,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN FILE_INFORMATION_CLASS</strong>
<em>FileInformationClass,</em></p>
<p><strong>IN BOOLEAN</strong> <em>ReturnSingleEntry,</em></p>
<p><strong>IN PUNICODE_STRING</strong> <em>FileName</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN BOOLEAN</strong> <em>RestartScan</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A file handle to an open directory file.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The number of bytes actually
written to the specified <em>Buffer</em> is stored in the
<em>Information</em> field of this variable. For more information about
this parameter see the <strong>NtCreateFile</strong> system service
description.</p>
<p><em>FileInformation</em> - A pointer to a buffer to receive
information about the files in the directory. The contents of this
buffer are defined by the <em>FileInformationClass</em> parameter
below.</p>
<p><em>Length</em> - The length of the specified buffer in bytes.</p>
<p><em>FileInformationClass</em> - Specifies the type of information
that is returned in the <em>FileInformation</em> buffer. The type of
information in the buffer is defined by the following type codes.</p>
<p><strong><u>FileInformationClass Values</u></strong></p>
<p><em>FileNamesInformation</em> - Specifies that names of files in the
directory are written to the <em>FileInformation</em> buffer.</p>
<p><em>FileDirectoryInformation</em> - Specifies that basic directory
information about the files is written to the <em>FileInformation</em>
buffer.</p>
<p><em>FileFullDirectoryInformation</em> - Specifies that all of the
directory information about the files is written to the
<em>FileInformation</em> buffer.</p>
<p><em>FileBothDirectoryInformation</em> - Specifies that all of the
directory information about the files is written to the
<em>FileInformation</em> buffer, including both of the file's names.</p>
<p><em>FileOleDirectoryInformation</em> - Specifies that OLE directory
information about the files is written to the <em>FileInformation</em>
buffer.</p>
<p><em>ReturnSingleEntry</em> - A BOOLEAN value that, if TRUE, indicates
that only a single entry should be returned.</p>
<p><em>FileName</em> - An optional file name within the specified
directory. This parameter may only be specified on the first call to the
service. It selects the files in the directory that the query calls
return. The specification may contain wildcard characters.</p>
<p><em>RestartScan</em> - A BOOLEAN value that, if TRUE, indicates that
the scan should be restarted from the beginning. This causes the
directory operation to restart the scan from the beginning of the
directory.</p>
</blockquote>
<p>The <strong>NtQueryDirectoryFile</strong> function operates on a
directory file specified by the <em>FileHandle</em> parameter. The
service returns information about files in the specified directory. The
<em>ReturnSingleEntry</em> parameter specifies that only a single entry
should be returned rather than filling the buffer. The actual number of
files whose information is returned, is the smallest of the
following:</p>
<blockquote>
<p>o - One entry, if the <em>ReturnSingleEntry</em> parameter is
TRUE.</p>
<p>o - The number of files whose information fits into the specified
buffer.</p>
<p>o - The number of files that exist in the directory according to the
wildcard file specification. This defaults to all of the files in the
directory.</p>
</blockquote>
<p>File systems supported by <strong>Windows NT</strong> return
information about files in directories in either random or
alphabetically ascending order. It is possible to receive information
about a specific file by specifying the name of the file as the
<em>FileName</em> parameter without using any wildcard characters.</p>
<p>If information about multiple files is returned, then each entry in
the buffer will be aligned on a longword or quadword boundary, depending
on the type of information being returned. Each type of information
class returned begins with the byte offset required to find the next
entry in the buffer. If this value is zero, then there are no more
entries following the current entry. Note that there are no entries in
the buffer only if the service completes with an error.</p>
<p>The normal operation of this service is to return all of the files in
the directory. A wildcard specification may be supplied the first time
the service is called to select a subset of the files in the directory.
This is done by supplying a wildcard file specification in the
<em>FileName</em> parameter the first time the service is invoked once
the directory file has been opened. Once a wildcard pattern has been
supplied, all subsequent <strong>NtQueryDirectoryFile</strong> calls
using the same directory handle operate only on those files which match
the pattern. That is, restarting the listing will return the first entry
in the directory that matches the pattern.</p>
<p>A wildcard file specification may only be supplied the first time
that the service is invoked. If no wildcard specification is supplied,
the file system assumes all of the files in the directory are selected.
Wildcard file specifications must be consistent with those used in
<strong>OS/2 V2.0</strong>.</p>
<p>Likewise, the <em>FileInformationClass</em> parameter specified the
first time indicates the type of information about the files in the
directory that is to be returned. Once an information class is
established, it may not be changed in subsequent calls to the service.
That is, all subsequent calls must pass the same information class as
the first call to the service for a given handle.</p>
<p>The information that is returned in the buffer is defined by the
following type codes and structures.</p>
<p><strong><u>FileNamesInformation Format by File Information
Class</u></strong></p>
<p><em>FileNamesInformation</em> - Data type is
<em>FILE_NAMES_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_NAMES_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_NAMES_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> Index in the directory of this entry</p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>The information returned for this information class is returned
longword aligned, and the <em>FileInformation</em> buffer itself must be
longword aligned.</p>
</blockquote>
<p><em>FileDirectoryInformation</em> - Data type is
<em>FILE_DIRECTORY_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_DIRECTORY_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_DIRECTORY_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The file index of this file in the
directory</p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the default
data stream, in bytes</p>
<p><strong>AllocationSize</strong> Allocated size of all data streams in
the file, in bytes</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p><strong>FileNameLength</strong> Length of the name of the file</p>
<p><strong>FileName</strong> Name of the file</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following
flags:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_DIRECTORY</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
</blockquote>
<p><em>FileFullDirectoryInformation</em> - Data type is
<em>FILE_FULL_DIR_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FULL_DIR_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>ULONG EaSize;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_FULL_DIR_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The file index of this file in the
directory</p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the default
data stream, in bytes</p>
<p><strong>AllocationSize</strong> Allocated size of all data streams in
the file, in bytes</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p><strong>FileNameLength</strong> Length of the name of the file</p>
<p><strong>EaSize</strong> Size of the EA's associated with the file</p>
<p><strong>FileName</strong> Name of the file</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following
flags:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_DIRECTORY</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
</blockquote>
<p><em>FileBothDirectoryInformation</em> - Data type is
<em>FILE_BOTH_DIR_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_BOTH_DIR_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>ULONG EaSize;</p>
<p>CCHAR ShortNameLength;</p>
<p>WCHAR ShortName[12];</p>
<p>WCHAR FileName[];</p>
<p>} FILE_BOTH_DIR_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The file index of this file in the
directory</p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the default
data stream, in bytes</p>
<p><strong>AllocationSize</strong> Allocated size of all data streams in
the file, in bytes</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p><strong>FileNameLength</strong> Length of the name of the file</p>
<p><strong>EaSize</strong> Size of the EA's associated with the file</p>
<p><strong>ShortNameLength</strong> Length of the 8.3 name of the
file</p>
<p><strong>ShortName</strong> 8.3 name of the file</p>
<p><strong>FileName</strong> Name of the file</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following
flags:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_DIRECTORY</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
</blockquote>
<p><em>FileOleDirectoryInformation</em> - Data type is
<em>FILE_OLE_DIR_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_DIR_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>FILE_STORAGE_TYPE StorageType;</p>
<p>GUID OleClassId;</p>
<p>ULONG OleStateBits;</p>
<p>BOOLEAN IsExplorable;</p>
<p>BOOLEAN HasExplorableChildren;</p>
<p>BOOLEAN ApplicationIsExplorable;</p>
<p>BOOLEAN ApplicationHasExplorableChildren;</p>
<p>BOOLEAN ContentIndexDisable;</p>
<p>BOOLEAN InheritContentIndexDisable;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_OLE_DIR_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The index of this file on the volume</p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the file</p>
<p><strong>AllocationSize</strong> Total allocation size of file,
including children</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p><strong>FileNameLength</strong> Length of the name of the file</p>
<p><strong>StorageType</strong> Storage type of the file</p>
<p><strong>OleClassId</strong> OLE class ID</p>
<p><strong>OleStateBits</strong> OLE state bits</p>
<p><strong>IsExplorable</strong> Indicates whether or not object is
explorable</p>
<p><strong>HasExplorableChildren</strong> Indicates whether or not
object has explorable children</p>
<p><strong>ApplicationHasExplorableChildren</strong>
Application-maintained version of above flag</p>
<p><strong>ContentIndexDisable</strong> Indicates whether content
indexing has been disabled</p>
<p><strong>InheritContentIndexDisable</strong> Indicates whether content
indexing disable is inheritable</p>
<p><strong>FileName</strong> Name of the entry</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following
flags:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_DIRECTORY</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
<p>The possible values for the storage type field are defined by the
<em>FILE_STORAGE_TYPE</em> enumerated type:</p>
<p>typedef enum _FILE_STORAGE_TYPE {</p>
<p>StorageTypeDirectory,</p>
<p>StorageTypeFile,</p>
<p>StorageTypeDocfile,</p>
<p>StorageTypeJunctionPoint,</p>
<p>StorageTypeCatalog,</p>
<p>StorageTypeStructuredStorage,</p>
<p>StorageTypeEmbedding,</p>
<p>StorageTypeStream</p>
<p>} FILE_STORAGE_TYPE;</p>
</blockquote>
<p><strong>FILE_LIST_DIRECTORY</strong> access to the directory is
required in order to obtain the above information about files in the
specified directory.</p>
<p>As in OS/2 today, users should not depend on any preconceived ideas
about the length of file names in <strong>Windows NT</strong>. Because
the system supports multiple file system types and will support more in
the future, it is difficult to tell just what form file names may take.
However, this service guarantees that for <strong>Windows NT</strong>
<strong>V3.1</strong>, a buffer that is large enough to contain at least
one <em>FILE_BOTH_DIR_INFORMATION</em> structure and has 256 Unicode
characters for a file name will be large enough to receive at least one
directory entry of any size.</p>
<p>Likewise, a buffer that is large enough to contain at least one name
should be at least 256 Unicode characters for the file name itself, plus
the size of the remainder of the structure.</p>
<p>Notice that it is legal for the caller to specify the
<em>RestartScan</em> parameter on a subsequent call to the
<strong>NtQueryDirectoryFile</strong> service to have the service
restart from the beginning of the directory listing. This causes the
scan of the directory to be restarted from the beginning of the list.
Notice also that since the file handle may be shared between separate
threads within a process, or in threads across processes when the handle
is inherited, not all of the directory entries may necessarily be seen
by a single thread. That is, the context being maintained to determine
which entry should be returned is common among the threads. Therefore,
if one thread obtains a directory entry, then the next thread to ask for
an entry will obtain the next entry, not the same entry as the first
thread.</p>
<p>Once the directory operation has completed, the <em>Event</em>, if
specified, will be set to the Signaled state. If no <em>Event</em>
parameter was specified, then the file object specified by the
<em>FileHandle</em> will be set to the Signaled state. If an
<em>ApcRoutine</em> was specified, it is invoked with the
<em>ApcContext</em> and the address of the <em>IoStatusBlock</em> as its
arguments.</p>
<h3 id="enumerating-files-in-an-ole-directory-file">Enumerating Files in
an Ole Directory File</h3>
<p>The files within an Ole directory file can be enumerate using the
<strong>NtQueryOleDirectoryFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryOleDirectoryFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle</em>,</p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em>,</p>
<p><strong>OUT PVOID</strong> <em>FileInformation</em>,</p>
<p><strong>IN ULONG</strong> <em>Length</em>,</p>
<p><strong>IN FILE_INFORMATION_CLASS</strong>
<em>FileInformationClass</em>,</p>
<p><strong>IN BOOLEAN</strong> <em>ReturnSingleEntry</em>,</p>
<p><strong>IN PUNICODE_STRING</strong> <em>FileName</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>IN BOOLEAN</strong> <em>RestartScan</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A file handle to an open container about which
information is to be returned.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The number of bytes actually
written to the specified <em>Buffer</em> is stored in the
<em>Information</em> field of this variable. For more information about
this parameter see the <strong>NtCreateFile</strong> system service
description.</p>
<p><em>FileInformation</em> - A pointer to a buffer to receive
information about the OLE embeddings and streams in the container. The
contents of this buffer are defined by the <em>FileInformationClass</em>
parameter below.</p>
<p><em>Length</em> - The length of the specified buffer in bytes.</p>
<p><em>FileInformationClass</em> - Specifies the type of information
that is returned in the <em>FileInformation</em> buffer. The type of
information in the buffer is defined by the following type codes.</p>
<p><strong><u>FileInformationClass Values</u></strong></p>
<p><em>FileDirectoryInformation</em> - Specifies that basic information
about the OLE embeddings and streams is written to the
<em>FileInformation</em> buffer.</p>
<p><em>FileOleDirectoryInformation</em> - Specifies that comprehensive
OLE information about the OLE embeddings and streams is written to the
<em>FileInformation</em> buffer.</p>
<p><em>ReturnSingleEntry</em> - A BOOLEAN value that, if TRUE, indicates
that only a single entry should be returned.</p>
<p><em>FileName</em> - An optional name within the specified container.
This parameter may only be specified on the first call to the service.
It selects the embeddings and streams in the container that the query
calls return. The specification may contain wildcard characters.</p>
<p><em>RestartScan</em> - A BOOLEAN value that, if TRUE, indicates that
the scan should be restarted from the beginning. This causes the
directory operation to restart the scan from the beginning of the
container.</p>
</blockquote>
<p>The <strong>NtQueryOleDirectoryFile</strong> function operates on a
container specified by the <em>FileHandle</em> parameter. The service
returns information about OLE embeddings and streams in the specified
container. The <em>ReturnSingleEntry</em> parameter specifies that only
a single entry should be returned rather than filling the buffer. The
actual number of files whose information is returned, is the smallest of
the following:</p>
<blockquote>
<p>o - One entry, if the <em>ReturnSingleEntry</em> parameter is
TRUE.</p>
<p>o - The number of entries whose information fits into the specified
buffer.</p>
<p>o - The number of entries that exist in the container according to
the wildcard specification. This defaults to all of the entries in the
container.</p>
</blockquote>
<p>If information about multiple entries is returned, then each entry in
the buffer will be aligned on a longword or quadword boundary, depending
on the type of information being returned. Each type of information
class returned begins with the byte offset required to find the next
entry in the buffer. If this value is zero, then there are no more
entries following the current entry. Note that there are no entries in
the buffer only if the service completes with an error.</p>
<p>The normal operation of this service is to return all of the entries
in the container. A wildcard specification may be supplied the first
time the service is called to select a subset of the entries in the
container. This is done by supplying a wildcard specification in the
<em>FileName</em> parameter the first time the service is invoked once
the container has been opened. Once a wildcard pattern has been
supplied, all subsequent <strong>NtQueryOleDirectoryFile</strong> calls
using the same handle operate only on those entries which match the
pattern. That is, restarting the listing will return the first entry in
the container that matches the pattern.</p>
<p>A wildcard specification may only be supplied the first time that the
service is invoked. If no wildcard specification is supplied, the file
system assumes all of the entries in the container are selected.
Wildcard specifications must be consistent with those used in
<strong>OS/2 V2.0</strong>.</p>
<p>Likewise, the <em>FileInformationClass</em> parameter specified the
first time indicates the type of information about the entries in the
container that is to be returned. Once an information class is
established, it may not be changed in subsequent calls to the service.
That is, all subsequent calls must pass the same information class as
the first call to the service for a given handle.</p>
<p>The information that is returned in the buffer is defined by the
following type codes and structures.</p>
<p><strong><u>FileNamesInformation Format by File Information
Class</u></strong></p>
<p><em>FileDirectoryInformation</em> - Data type is
<em>FILE_DIRECTORY_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_DIRECTORY_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_DIRECTORY_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The index of this entry in the
container</p>
<p><strong>CreationTime</strong> Date/time that the entry was
created</p>
<p><strong>LastAccessTime</strong> Date/time that the entry was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the entry was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the entry was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the default
data stream, in bytes</p>
<p><strong>AllocationSize</strong> Total allocated size of the OLE
embedding or stream in bytes</p>
<p><strong>FileAttributes</strong> Attributes of the OLE embedding or
stream</p>
<p><strong>FileNameLength</strong> Length of the name of the entry</p>
<p><strong>FileName</strong> Name of the entry</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following flags
if the object is an embedding. Otherwise, the file attributes field will
be zero.</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
</blockquote>
<p><em>FileOleDirectoryInformation</em> - Data type is
<em>FILE_OLE_DIR_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_DIR_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG FileIndex;</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>ULONG FileAttributes;</p>
<p>ULONG FileNameLength;</p>
<p>FILE_STORAGE_TYPE StorageType;</p>
<p>GUID OleClassId;</p>
<p>ULONG OleStateBits;</p>
<p>BOOLEAN IsExplorable;</p>
<p>BOOLEAN HasExplorableChildren;</p>
<p>BOOLEAN ApplicationIsExplorable;</p>
<p>BOOLEAN ApplicationHasExplorableChildren;</p>
<p>BOOLEAN ContentIndexDisable;</p>
<p>BOOLEAN InheritContentIndexDisable;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_OLE_DIR_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>FileIndex</strong> The index of this object on the volume</p>
<p><strong>CreationTime</strong> Date/time that the entry was
created</p>
<p><strong>LastAccessTime</strong> Date/time that the entry was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the entry was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the entry was last
changed</p>
<p><strong>EndOfFile</strong> Offset to first free byte in the default
data stream, in bytes</p>
<p><strong>AllocationSize</strong> Allocated size of the OLE embedding
or stream in bytes</p>
<p><strong>FileAttributes</strong> Attributes of the OLE embedding or
stream</p>
<p><strong>FileNameLength</strong> Length of the name of the entry</p>
<p><strong>StorageType</strong> Storage type of the entry</p>
<p><strong>OleClassId</strong> OLE class ID</p>
<p><strong>OleStateBits</strong> OLE state bits</p>
<p><strong>IsExplorable</strong> Indicates whether or not object is
explorable</p>
<p><strong>HasExplorableChildren</strong> Indicates whether or not
object has explorable children</p>
<p><strong>ApplicationHasExplorableChildren</strong>
Application-maintained version of above flag</p>
<p><strong>ContentIndexDisable</strong> Indicates whether content
indexing has been disabled</p>
<p><strong>InheritContentIndexDisable</strong> Indicates whether CI
disable should be inherited</p>
<p><strong>FileName</strong> Name of the entry</p>
<p>The information returned for this information class is returned
quadword aligned, and the <em>FileInformation</em> buffer itself must be
quadword aligned.</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following flags
if the object is an embedding. Otherwise it will be zero.</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>The <strong>FILE_ATTRIBUTE_NORMAL</strong> flag will never be
returned in combination with any other flag.</p>
<p>The possible values for the storage type field are defined by the
<em>FILE_STORAGE_TYPE</em> enumerated type:</p>
<p>typedef enum _FILE_STORAGE_TYPE {</p>
<p>StorageTypeDirectory,</p>
<p>StorageTypeFile,</p>
<p>StorageTypeDocfile,</p>
<p>StorageTypeJunctionPoint,</p>
<p>StorageTypeCatalog,</p>
<p>StorageTypeStructuredStorage,</p>
<p>StorageTypeEmbedding,</p>
<p>StorageTypeStream</p>
<p>} FILE_STORAGE_TYPE;</p>
</blockquote>
<p><strong>FILE_LIST_DIRECTORY</strong> access to the container is
required in order to obtain the above information about OLE embeddings
and streams in the specified container.</p>
<p>In the case of the <strong>NtQueryOleDirectoryFile</strong>, users
can depend on the maximum length of a file name being 31 Unicode
characters, because that is the maximum length defined by OLE.
Therefore, the name of any stream, property set, embedding, etc., is
guaranteed to be a maximum of 31 Unicode characters because this API
only operates on OLE objects.</p>
<p>Likewise, a buffer that is large enough to contain at least one name
should be at least 31 Unicode characters for the file name itself, plus
the size of the remainder of the structure.</p>
<p>Notice that it is legal for the caller to specify the
<em>RestartScan</em> parameter on a subsequent call to the
<strong>NtQueryOleDirectoryFile</strong> service to have the service
restart from the beginning of the listing. This causes the scan of the
container to be restarted from the beginning of the list. Notice also
that since the file handle may be shared between separate threads within
a process, or in threads across processes when the handle is inherited,
not all of the entries may necessarily be seen by a single thread. That
is, the context being maintained to determine which entry should be
returned is common among the threads. Therefore, if one thread obtains
an entry, then the next thread to ask for an entry will obtain the next
entry, not the same entry as the first thread.</p>
<p>Once the operation has completed, the <em>Event</em>, if specified,
will be set to the Signaled state. If no <em>Event</em> parameter was
specified, then the file object specified by the <em>FileHandle</em>
will be set to the Signaled state. If an <em>ApcRoutine</em> was
specified, it is invoked with the <em>ApcContext</em> and the address of
the <em>IoStatusBlock</em> as its arguments.</p>
<h3 id="monitoring-directory-modifications">Monitoring Directory
Modifications</h3>
<p>Directory modifications can be monitored using the
<strong>NtNotifyChangeDirectoryFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtNotifyChangeDirectoryFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>Buffer,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN ULONG</strong> <em>CompletionFilter,</em></p>
<p><strong>IN BOOLEAN</strong> <em>WatchTree</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open directory file.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>Buffer</em> - A variable to receive the name(s) of the file(s)
that changed in the specified target directory.</p>
<p><em>Length</em> - Specifies the length of the <em>Buffer</em>.</p>
<p><em>CompletionFilter</em> - Specifies a set of flags that indicate
the types of operations on the directory or files in the directory that
cause the I/O request to complete. The following are the valid flags for
this parameter:</p>
<p><strong><u>CompletionFilter Flags</u></strong></p>
<p><em>FILE_NOTIFY_CHANGE_FILE_NAME</em> - Specifies that the I/O
operation should be completed if a file is added, deleted, or
renamed.</p>
<p><em>FILE_NOTIFY_CHANGE_DIR_NAME</em> - Specifies that the I/O
operation should be completed if a subdirectory is added, deleted, or
renamed.</p>
<p><em>FILE_NOTIFY_CHANGE_NAME</em> - Specifies that the I/O operation
should be completed if a file or a subdirectory is added, deleted, or
renamed.</p>
<p><em>FILE_NOTIFY_CHANGE_ATTRIBUTES</em> - Specifies that the I/O
operation should be completed if the attributes of a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_SIZE</em> - Specifies that the I/O operation
should be completed if the allocation size or end of file for a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_LAST_WRITE</em> - Specifies that the I/O
operation should be completed if the last write date/time for a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_LAST_ACCESS</em> - Specifies that the I/O
operation should be completed if the last access date/time for a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_CREATION</em> - Specifies that the I/O
operation should be completed if the creation date/time for a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_EA</em> - Specifies that the I/O operation
should be completed if the EAs for a file or subdirectory are
changed.</p>
<p><em>FILE_NOTIFY_CHANGE_SECURITY</em> - Specifies that the I/O
operation should be completed if the security information for a file or
subdirectory is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_STREAM_NAME</em> - Specifies that the I/O
operation should be completed if the name of an alternate data stream is
changed.</p>
<p><em>FILE_NOTIFY_CHANGE_STREAM_SIZE</em> - Specifies that the I/O
operation should be completed if the size of an alternated data stream
is changed.</p>
<p><em>FILE_NOTIFY_CHANGE_STREAM_WRITE</em> - Specifies that the I/O
operation should be completed if an alternate data stream is changed due
to a write operation.</p>
<p><em>WatchTree</em> - A BOOLEAN value that, if TRUE, specifies that
all changes to files below the directory should also be reported.</p>
</blockquote>
<p>The <strong>NtNotifyChangeDirectoryFile</strong> service notifies the
caller when files in the directory or directory tree specified by the
<em>FileHandle</em> are modified. It also returns the name(s) of the
file(s) that changed. All names are specified relative to the directory
that the handle represents. The service completes once the directory or
directory tree has been modified based on the supplied
<em>CompletionFilter</em>. The service is a "single shot" and therefore
needs to be reinvoked to watch the directory for changes again.</p>
<p>The operation of this service begins by opening a directory for
<strong>FILE_LIST_DIRECTORY</strong> access. Once the handle is
returned, the <strong>NtNotifyChangeDirectoryFile</strong> service may
be invoked to begin watching files and subdirectories in the specified
target for changes. The first time the service is invoked, the
<em>Length</em> parameter supplies the size not only of the user's
<em>Buffer</em>, but also the buffer that will be used by the file
system to store names of files that have changed. Likewise, the
<em>CompletionFile</em> and <em>WatchTree</em> parameters on the first
call indicate how notification should operate for all calls using the
supplied <em>FileHandle</em>. These two parameters are ignored on
subsequent calls to the API.</p>
<p>Once a modification is made that should be reported, the system will
complete the service. The names of the files that have changed since the
last time the service was called will be placed into the caller's output
buffer. The <em>Information</em> field of the I/O status block indicates
the number of bytes that were written to the output buffer. If too many
files have changed since the last time the service was called, then zero
bytes will be written to the buffer and an alternate status code is
returned in the <em>Status</em> field of the I/O status block. For the
latter case, the application must enumerate the files in the directory
or directory tree to note changes.</p>
<p>The format of the data written to the output <em>Buffer</em> is
defined by the following structure:</p>
<p>typedef struct _FILE_NOTIFY_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>ULONG Action;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
</blockquote>
<p>} FILE_NOTIFY_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>Action</strong> Description of what happened to cause this
entry</p>
<p><strong>FileNameLength</strong> Length of the file name that
changed</p>
<p><strong>FileName</strong> Name of the file that changed</p>
<p>The value of the <em>Action</em> field is defined as one of the
following:</p>
<p><strong><u>Value Description</u></strong></p>
<p><strong>FILE_ADDED</strong> The file was added to the directory</p>
<p><strong>FILE_REMOVED</strong> The file was removed from the
directory</p>
<p><strong>FILE_MODIFIED</strong> The file was modified</p>
<p><strong>FILE_RENAMED_OLD_NAME</strong> The name of the file that was
renamed</p>
<p><strong>FILE_RENAMED_NEW_NAME</strong> The new name of the file that
was renamed</p>
<p>When a file is renamed within a single directory, then two entries
will be placed into the output buffer: the old name of the file and the
new name of the file. If the file is renamed from the directory being
monitored to another directory, then only a single entry will be placed
into the output buffer with an action type of <em>Removed</em>.</p>
<p>This service requires <strong>FILE_LIST_DIRECTORY</strong> access to
the directory file that was actually modified. If the operation is
watching a directory tree, then the caller must have
<strong>FILE_TRAVERSE</strong> access to all intervening directories
from the grandparent of the modified file, to the directory specified by
the <em>FileHandle</em> parameter. It is possible to bypass security
checks to all directories if the caller has the
<strong>SeNotifyChangePrivilege</strong> privilege.</p>
<p>It should be noted that because of the use of both symbolic and hard
links within some file systems, the results of changes to directories
within a tree may be unpredictable. That is, some changes may only be
seen because the <em>FileHandle</em> used refers to a point in the tree
through which the change was actually made. Changes made to a point
lower in the tree may not be seen because the path used to make the
change did not traverse the directory referred to by the
<em>FileHandle</em>.</p>
<p>It should also be noted that this API may not be implemented by some
older network servers. In this case, the API will return a status
indicating that it is not implemented. Applications using this API
should be prepared to enumerate directories or directory trees in this
case.</p>
<p>Once a modification is made to the directory or directory tree, the
<em>Event</em>, if specified, will be set to the Signaled state. If no
<em>Event</em> parameter was specified, then the file object specified
by the <em>FileHandle</em> will be set to the Signaled state. If an
<em>ApcRoutine</em> was specified, it is invoked with the
<em>ApcContext</em> and the address of the <em>IoStatusBlock</em> as its
arguments.</p>
<h2 id="file-services">File Services</h2>
<p>This section presents those services that control files and obtain
and change information about files.</p>
<p>The APIs that perform these functions are as follows:</p>
<blockquote>
<p><strong>NtQueryInformationFile</strong> - Obtain information about a
file.</p>
<p><strong>NtSetInformationFile</strong> - Change information on a
file.</p>
<p><strong>NtQueryEaFile</strong> - Obtain extended attributes for a
file.</p>
<p><strong>NtSetEaFile</strong> - Set extended attributes for a
file.</p>
<p><strong>NtLockFile</strong> - Lock a byte range within a file.</p>
<p><strong>NtUnlockFile</strong> - Unlock a byte range within a
file.</p>
</blockquote>
<h3 id="obtaining-information-about-a-file">Obtaining Information about
a File</h3>
<p>Information about a file may be obtained using the
<strong>NtQueryInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>FileInformation,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN FILE_INFORMATION_CLASS</strong>
<em>FileInformationClass</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The number of bytes actually
written to the specified <em>Buffer</em> is stored in the
<em>Information</em> field of this variable. For more information about
this parameter see the <strong>NtCreateFile</strong> system service
description.</p>
<p><em>FileInformation</em> - A pointer to a buffer to receive the
desired information about the file. The contents of this buffer are
defined by the <em>FileInformationClass</em> parameter described
below.</p>
<p><em>Length</em> - The length of the <em>FileInformation</em> buffer
in bytes.</p>
<p><em>FileInformationClass</em> - Specifies the type of information
that should be returned about the file. The information returned in the
<em>FileInformation</em> buffer is defined by the following type
codes:</p>
<p><strong><u>FileInformationClass Values</u></strong></p>
<p><em>FileBasicInformation</em> - Returns basic information about the
specified file. <strong>FILE_READ_ATTRIBUTES</strong> access to the file
is required. Also see the <strong>NtQueryAttributesFile</strong> service
description.</p>
<p><em>FileStandardInformation</em> - Returns standard information about
the specified file. No specific access to the file is required; that is,
this information is available as long as the file is open.</p>
<p><em>FileInternalInformation</em> - Returns file system internal
information about the file. No specific access to the file is required;
that is, this information is available as long as the file is open.</p>
<p><em>FileEaInformation</em> - Returns the size of the extended
attributes structures associated with the file. No specific access to
the file is required; that is, this information is available as long as
the file is open.</p>
<p><em>FileAccessInformation</em> - Returns the access that the caller
has to the file. No specific access to the file is required; that is,
this information is available as long as the file is open.</p>
<p><em>FileNameInformation</em> - Returns the volume-relative name of
the file. No specific access to the file is required; that is, this
information is available as long as the file is open.</p>
<p><em>FilePositionInformation</em> - Returns the current file position
for the file. <strong>FILE_READ_DATA</strong> or
<strong>FILE_WRITE_DATA</strong> access to the file is required.</p>
<p><em>FileModeInformation</em> - Returns information about how the file
is open for the specified file handle. No specific access to the file is
required; that is, this information is available as long as the file is
open.</p>
<p><em>FileAlignmentInformation</em> - Returns information about the
alignment requirements for buffers being read or written to the file.
This is useful when the file has been opened without intermediate
buffering enabled. No specific access to the file is required; that is,
this information is available as long as the file is open.</p>
<p><em>FileAllInformation</em> - Returns all of the above information in
one structure. <strong>FILE_READ_ATTRIBUTES</strong> access to the file
is required to obtain this information. In order for the file position
information to be returned, the accessor must have either
<strong>FILE_READ_DATA</strong> or <strong>FILE_WRITE_DATA</strong>
access to the file.</p>
<p><em>FileAlternateNameInformation</em> - Returns the DOS format 8.3
alternate name for the file, if it has one.</p>
<p><em>FileStreamInformation</em> - Returns the names of the alternate
data streams for the file, if any exist.</p>
<p><em>FileCompressionInformation</em> - Returns the compression
information about a file. No specific access to the file is required;
that is, this information is available as long as the file is open.</p>
<p><em>FileOleInformation</em> - Returns the OLE-specific information
about a file. <strong>FILE_READ_ATTRIBUTES</strong> access to the file
is required to obtain this information.</p>
<p><em>FileOleAllInformation</em> - Returns the all of the OLE-specific
information about a file. <strong>FILE_READ_ATTRIBUTES</strong> access
to the file is required to obtain this information. In order for the
file position information to be returned, the accessor must have either
<strong>FILE_READ_DATA</strong> or <strong>FILE_WRITE_DATA</strong>
access to the file.</p>
</blockquote>
<p>The <strong>NtQueryInformationFile</strong> service returns
information about the specified file. The information returned in the
buffer is defined by the following type codes and structures. Note that
the fields that are not supported for a given device or file system are
returned as zero. For example, the FAT file system does not support a
creation time, so this field is set to zero.</p>
<p><strong><u>FileInformation Format by File Information
Class</u></strong></p>
<p><em>FileBasicInformation</em> - Data type is
<em>FILE_BASIC_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_BASIC_INFORMATION {</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>ULONG FileAttributes;</p>
<p>} FILE_BASIC_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p>All dates and times are returned in the standard <strong>Windows
NT</strong> system-time format.</p>
<p>The file attributes field can be a combination of the following
flags:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_DIRECTORY</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>Note that the <strong>FILE_ATTRIBUTE_NORMAL</strong> attribute will
never be returned in combination with any other attributes, as all other
attributes override this attribute. Also see the
<strong>NtQueryAttributesFile</strong> service description.</p>
</blockquote>
<p><em>FileStandardInformation</em> - Data type is
<em>FILE_STANDARD_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_STANDARD_INFORMATION {</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>DEVICE_TYPE DeviceType;</p>
<p>ULONG NumberOfLinks;</p>
<p>BOOLEAN DeletePending;</p>
<p>BOOLEAN Directory;</p>
<p>} FILE_STANDARD_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>AllocationSize</strong> Allocated size of the file in
bytes</p>
<p><strong>EndOfFile</strong> Offset to the first free byte in the
file</p>
<p><strong>DeviceType</strong> Device type code</p>
<p><strong>NumberOfLinks</strong> Number of hard links to the file</p>
<p><strong>DeletePending</strong> Indicates whether the file is marked
for deletion</p>
<p><strong>Directory</strong> Indicates whether the file is a
directory</p>
<p>The end of file field specifies the byte offset to the end of the
file. Note that because this value is zero-based, it actually refers to
the first free byte in the file; that is, it is the offset to the next
byte after the last valid byte in the file.</p>
<p>Device types have the following valid values:</p>
<p><strong>FILE_DEVICE_BATTERY</strong></p>
<p><strong>FILE_DEVICE_BEEP</strong></p>
<p><strong>FILE_DEVICE_BUS_EXTENDER</strong></p>
<p><strong>FILE_DEVICE_CD_ROM</strong></p>
<p><strong>FILE_DEVICE_CD_ROM_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_CONTROLLER</strong></p>
<p><strong>FILE_DEVICE_DATALINK</strong></p>
<p><strong>FILE_DEVICE_DFS</strong></p>
<p><strong>FILE_DEVICE_DISK</strong></p>
<p><strong>FILE_DEVICE_DISK_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_INPORT_PORT</strong></p>
<p><strong>FILE_DEVICE_KEYBOARD</strong></p>
<p><strong>FILE_DEVICE_MAILSLOT</strong></p>
<p><strong>FILE_DEVICE_MIDI_IN</strong></p>
<p><strong>FILE_DEVICE_MIDI_OUT</strong></p>
<p><strong>FILE_DEVICE_MOUSE</strong></p>
<p><strong>FILE_DEVICE_MULTI_UNC_PROVIDER</strong></p>
<p><strong>FILE_DEVICE_NAMED_PIPE</strong></p>
<p><strong>FILE_DEVICE_NETWORK</strong></p>
<p><strong>FILE_DEVICE_NETWORK_BROWSER</strong></p>
<p><strong>FILE_DEVICE_NETWORK_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_NETWORK_REDIRECTOR</strong></p>
<p><strong>FILE_DEVICE_NULL</strong></p>
<p><strong>FILE_DEVICE_PARALLEL_PORT</strong></p>
<p><strong>FILE_DEVICE_PHYSICAL_NETCARD</strong></p>
<p><strong>FILE_DEVICE_PRINTER</strong></p>
<p><strong>FILE_DEVICE_SCANNER</strong></p>
<p><strong>FILE_DEVICE_SCREEN</strong></p>
<p><strong>FILE_DEVICE_SERIAL_MOUSE_PORT</strong></p>
<p><strong>FILE_DEVICE_SERIAL_PORT</strong></p>
<p><strong>FILE_DEVICE_SOUND</strong></p>
<p><strong>FILE_DEVICE_STREAMS</strong></p>
<p><strong>FILE_DEVICE_TAPE</strong></p>
<p><strong>FILE_DEVICE_TAPE_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_TRANSPORT</strong></p>
<p><strong>FILE_DEVICE_UNKNOWN</strong></p>
<p><strong>FILE_DEVICE_VIDEO</strong></p>
<p><strong>FILE_DEVICE_VIRTUAL_DISK</strong></p>
<p><strong>FILE_DEVICE_WAVE_IN</strong></p>
<p><strong>FILE_DEVICE_WAVE_OUT</strong></p>
<p><strong>FILE_DEVICE_8042_PORT</strong></p>
<p>No specific access is required to obtain this information about the
file; that is, this information is obtainable as long as the file is
open.</p>
</blockquote>
<p><em>FileInternalInformation</em> - Data type is
<em>FILE_INTERNAL_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_INTERNAL_INFORMATION {</p>
<p>LARGE_INTEGER IndexNumber;</p>
<p>} FILE_INTERNAL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>IndexNumber</strong> A file system unique file identifier</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is obtainable as long as the
file is open.</p>
</blockquote>
<p><em>FileEaInformation</em> - Data type is
<em>FILE_EA_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_EA_INFORMATION {</p>
<p>ULONG EaSize;</p>
<p>} FILE_EA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>EaSize</strong> Size of file's extended attributes in
bytes</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is obtainable as long as the
file is open.</p>
</blockquote>
<p><em>FileAccessInformation</em> - Data type is
<em>FILE_ACCESS_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_ACCESS_INFORMATION {</p>
<p>ACCESS_MASK AccessFlags;</p>
<p>} FILE_ACCESS_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>AccessFlags</strong> Access that the caller has to the
file</p>
<p>The valid flags that may be set in the <strong>AccessFlags</strong>
field are as follows:</p>
<p><strong>SYNCHRONIZE</strong></p>
<p><strong>DELETE</strong></p>
<p><strong>READ_CONTROL</strong></p>
<p><strong>WRITE_DAC</strong></p>
<p><strong>WRITE_OWNER</strong></p>
<p><strong>FILE_READ_EA</strong></p>
<p><strong>FILE_WRITE_EA</strong></p>
<p><strong>FILE_READ_ATTRIBUTES</strong></p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong></p>
<p><strong>FILE_READ_DATA</strong></p>
<p><strong>FILE_WRITE_DATA</strong></p>
<p><strong>FILE_EXECUTE</strong></p>
<p><strong>FILE_APPEND_DATA</strong></p>
<p>If the file is a directory, then the <strong>FILE_READ_DATA</strong>
through <strong>FILE_APPEND_DATA</strong> flags are invalid. They are
replaced by the following valid values:</p>
<p><strong>FILE_LIST_DIRECTORY</strong></p>
<p><strong>FILE_TRAVERSE</strong></p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open.</p>
</blockquote>
<p><em>FileNameInformation</em> - Data type is
<em>FILE_NAME_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_NAME_INFORMATION {</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_NAME_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open.</p>
</blockquote>
<p><em>FilePositionInformation</em> - Data type is
<em>FILE_POSITION_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_POSITION_INFORMATION {</p>
<p>LARGE_INTEGER CurrentByteOffset;</p>
<p>} FILE_POSITION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CurrentByteOffset</strong> Current byte offset within the
file</p>
<p>In order for the information to be valid, the file must have been
opened or created specifying synchronous I/O.</p>
<p><strong>FILE_READ_DATA</strong> or <strong>FILE_WRITE_DATA</strong>
access to the file is required to obtain this information about the
file.</p>
</blockquote>
<p><em>FileModeInformation</em> - Data type is
<em>FILE_MODE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_MODE_INFORMATION {</p>
<p>ULONG Mode;</p>
<p>} FILE_MODE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>Mode</strong> Current open mode of file handle to the
file</p>
<p>The mode flags that may be returned are as follows:</p>
<p><strong>FILE_WRITE_THROUGH</strong></p>
<p><strong>FILE_SEQUENTIAL_ONLY</strong></p>
<p><strong>FILE_NO_INTERMEDIATE_BUFFERING</strong></p>
<p><strong>FILE_SYNCHRONOUS_IO_ALERT</strong></p>
<p><strong>FILE_SYNCHRONOUS_IO_NONALERT</strong></p>
<p><strong>FILE_DELETE_ON_CLOSE</strong></p>
<p>Note that only one of the synchronous I/O flags will be returned.</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open.</p>
</blockquote>
<p><em>FileAlignmentInformation</em> - Data type is
<em>FILE_ALIGNMENT_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_ALIGNMENT_INFORMATION {</p>
<p>ULONG AlignmentRequirement;</p>
<p>} FILE_ALIGNMENT_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>AlignmentRequirement</strong> Buffer alignment required by
device</p>
<p>The value of this field is one of the following:</p>
<p><strong>FILE_BYTE_ALIGNMENT</strong></p>
<p><strong>FILE_WORD_ALIGNMENT</strong></p>
<p><strong>FILE_LONG_ALIGNMENT</strong></p>
<p><strong>FILE_QUAD_ALIGNMENT</strong></p>
<p><strong>FILE_OCTA_ALIGNMENT</strong></p>
<p><strong>FILE_32_BYTE_ALIGNMENT</strong></p>
<p><strong>FILE_64_BYTE_ALIGNMENT</strong></p>
<p><strong>FILE_128_BYTE_ALIGNMENT</strong></p>
<p><strong>FILE_256_BYTE_ALIGNMENT</strong></p>
<p><strong>FILE_512_BYTE_ALIGNMENT</strong></p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open.</p>
</blockquote>
<p><em>FileAllInformation</em> - Data type is
<em>FILE_ALL_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_ALL_INFORMATION {</p>
<p>FILE_BASIC_INFORMATION BasicInformation;</p>
<p>FILE_STANDARD_INFORMATION StandardInformation;</p>
<p>FILE_INTERNAL_INFORMATION InternalInformation;</p>
<p>FILE_EA_INFORMATION EaInformation;</p>
<p>FILE_ACCESS_INFORMATION AccessInformation;</p>
<p>FILE_POSITION_INFORMATION PositionInformation;</p>
<p>FILE_MODE_INFORMATION ModeInformation;</p>
<p>FILE_ALIGNMENT_INFORMATION AlignmentInformation;</p>
<p>FILE_NAME_INFORMATION NameInformation;</p>
<p>} FILE_ALL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>BasicInformation</strong> Basic information</p>
<p><strong>StandardInformation</strong> Standard information</p>
<p><strong>InternalInformation</strong> Internal information</p>
<p><strong>EaInformation</strong> Extended attributes size
information</p>
<p><strong>AccessInformation</strong> Access information</p>
<p><strong>PositionInformation</strong> Current position information</p>
<p><strong>ModeInformation</strong> Mode information</p>
<p><strong>AlignmentInformation</strong> Alignment requirement
information</p>
<p><strong>NameInformation</strong> File name information</p>
<p>Notice that the position information will be valid only if the file
was opened or created using one of the synchronous I/O options.</p>
<p><strong>FILE_READ_ATTRIBUTES</strong> access to the file is required
to obtain this information. If the file was opened for synchronous I/O,
then the position information will only be valid if the accessor has
either <strong>FILE_READ_DATA</strong> or
<strong>FILE_WRITE_DATA</strong> access to the file.</p>
</blockquote>
<p><em>FileAlternateNameInformation</em> - Data type is
<em>FILE_NAME_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_NAME_INFORMATION {</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_NAME_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open. Note that some files do not have alternate names.</p>
</blockquote>
<p><em>FileStreamInformation</em> - Data type is
<em>FILE_STREAM_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_STREAM_INFORMATION {</p>
<p>ULONG NextEntryOffset;</p>
<p>ULONG StreamNameLength;</p>
<p>LARGE_INTEGER StreamSize;</p>
<p>LARGE_INTEGER StreamAllocationSize;</p>
<p>WCHAR StreamName;</p>
<p>} FILE_STREAM_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset to the next entry in
bytes</p>
<p><strong>StreamNameLength</strong> Length of the name of the stream in
bytes</p>
<p><strong>StreamSize</strong> Size of the stream</p>
<p><strong>StreamAllocationSize</strong> Allocation size of the
stream</p>
<p><strong>StreamName</strong> Name of the stream</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is obtainable as long as the
file is open.</p>
</blockquote>
<p><em>FileCompressionInformation</em> - Data type is
<em>FILE_COMPRESSION_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_COMPRESSION_INFORMATION {</p>
<p>LARGE_INTEGER CompressedFileSize;</p>
<p>USHORT CompressionFormat;</p>
<p>} FILE_COMPRESSION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CompressedFileSize</strong> Size of the compressed file in
bytes</p>
<p><strong>CompressionFormat</strong> Compression algorithm code</p>
<p>No specific access to the file is required to obtain this information
about the file; that is, this information is available as long as the
file is open. Note that if the file is not compressed, then the
<em>CompressionFormat</em> field is set to zero.</p>
</blockquote>
<p><em>FileOleInformation</em> - Data type is
<em>FILE_OLE_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_INFORMATION {</p>
<p>FILE_OLE_CLASSID_INFORMATION OleClassIdInformation;</p>
<p>FILE_OBJECTID_INFORMATION ObjectIdInformation;</p>
<p>FILE_STORAGE_TYPE StorageType;</p>
<p>ULONG OleStateBits;</p>
<p>BOOLEAN ApplicationIsExplorable;</p>
<p>BOOLEAN ApplicationHasExplorableChildren;</p>
<p>BOOLEAN ContentIndexDisable;</p>
<p>BOOLEAN InheritContentIndexDisable;</p>
<p>} FILE_OLE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>OleClassIdInformation</strong> OLE class ID for the file</p>
<p><strong>ObjectIdInformation</strong> Object ID for the file</p>
<p><strong>OleStateBits</strong> OLE state bits for file</p>
<p><strong>ApplicationIsExplorable</strong> Application-defined notion
of explorability</p>
<p><strong>ApplicationHasExplorableChildren</strong> Application-defined
notion of children’s explorability</p>
<p><strong>ContentIndexDisable</strong> Enable/disable content
indexing</p>
<p><strong>InheritContentIndexDisable</strong> Enable/disable content
indexing of children</p>
<p>The possible values for the storage type field are defined by the
<em>FILE_STORAGE_TYPE</em> enumerated type:</p>
<p>typedef enum _FILE_STORAGE_TYPE {</p>
<p>StorageTypeDirectory,</p>
<p>StorageTypeFile,</p>
<p>StorageTypeDocfile,</p>
<p>StorageTypeJunctionPoint,</p>
<p>StorageTypeCatalog,</p>
<p>StorageTypeStructuredStorage,</p>
<p>StorageTypeEmbedding,</p>
<p>StorageTypeStream</p>
<p>} FILE_STORAGE_TYPE;</p>
<p><strong>FILE_READ_ATTRIBUTES</strong> access to the file is required
to obtain this information.</p>
</blockquote>
<p><em>FileOleAllInformation</em> - Data type is
<em>FILE_OLE_ALL_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_ALL_INFORMATION {</p>
<p>FILE_BASIC_INFORMATION BasicInformation;</p>
<p>FILE_STANDARD_INFORMATION StandardInformation;</p>
<p>FILE_INTERNAL_INFORMATION InternalInformation;</p>
<p>FILE_EA_INFORMATION EaInformation;</p>
<p>FILE_ACCESS_INFORMATION AccessInformation;</p>
<p>FILE_POSITION_INFORMATION PositionInformation;</p>
<p>FILE_MODE_INFORMATION ModeInformation;</p>
<p>FILE_ALIGNMENT_INFORMATION AlignmentInformation;</p>
<p>USN Usn;</p>
<p>FILE_OLE_CLASSID_INFORMATION OleClassIdInformation;</p>
<p>FILE_OBJECTID_INFORMATION ObjectIdInformation;</p>
<p>FILE_STORAGE_TYPE StorageType;</p>
<p>ULONG OleStateBits;</p>
<p>ULONG OleId;</p>
<p>ULONG NumberOfStreamReferences;</p>
<p>ULONG StreamIndex;</p>
<p>BOOLEAN IsExplorable;</p>
<p>BOOLEAN HasExplorableChildren;</p>
<p>BOOLEAN ApplicationExplorable;</p>
<p>BOOLEAN ApplicationHasExplorableChildren;</p>
<p>BOOLEAN ContentIndexDisable;</p>
<p>BOOLEAN InheritContentIndexDisable;</p>
<p>FILE_NAME_INFORMATION NameInformation;</p>
<p>} FILE_OLE_ALL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>BasicInformation</strong> Basic information</p>
<p><strong>StandardInformation</strong> Standard information</p>
<p><strong>InternalInformation</strong> Internal information</p>
<p><strong>EaInformation</strong> Extended attributes size
information</p>
<p><strong>AccessInformation</strong> Access information</p>
<p><strong>PositionInformation</strong> Current position information</p>
<p><strong>ModeInformation</strong> Mode information</p>
<p><strong>AlignmentInformation</strong> Alignment requirement
information</p>
<p><strong>Usn</strong> Update sequence number</p>
<p><strong>OleClassIdInformation</strong> OLE Class ID for the file</p>
<p><strong>ObjectIdInformation</strong> Object ID for the file</p>
<p><strong>StorageType</strong> Storage type of the file</p>
<p><strong>OleStateBits</strong> OLE state flags</p>
<p><strong>OleId</strong> OLE ID for the file</p>
<p><strong>NumberOfStreamReferences</strong> Reference count for the
stream</p>
<p><strong>StreamIndex</strong> Volume index for this stream</p>
<p><strong>IsExplorable</strong> Indicates whether the file is
explorable</p>
<p><strong>HasExplorableChildren</strong> Indicates whether the file has
explorable children</p>
<p><strong>ApplicationExplorable</strong> Application version of
explorable</p>
<p><strong>ApplicationHasExplorableChildren</strong> Application version
of explorable children</p>
<p><strong>ContentIndexDisable</strong> Indicates whether content
indexing is disabled</p>
<p><strong>InheritContextIndexDisable</strong> Indicates whether CI
disable state is inherited</p>
<p><strong>NameInformation</strong> File name information</p>
<p>The possible values for the storage type field are defined by the
<em>FILE_STORAGE_TYPE</em> enumerated type:</p>
<p>typedef enum _FILE_STORAGE_TYPE {</p>
<p>StorageTypeDirectory,</p>
<p>StorageTypeFile,</p>
<p>StorageTypeDocfile,</p>
<p>StorageTypeJunctionPoint,</p>
<p>StorageTypeCatalog,</p>
<p>StorageTypeStructuredStorage,</p>
<p>StorageTypeEmbedding,</p>
<p>StorageTypeStream</p>
<p>} FILE_STORAGE_TYPE;</p>
<p>Notice that the position information will be valid only if the file
was opened or created using one of the synchronous I/O options.</p>
<p><strong>FILE_READ_ATTRIBUTES</strong> access to the file is required
to obtain this information. If the file was opened for synchronous I/O,
then the position information will only be valid if the accessor has
either <strong>FILE_READ_DATA</strong> or
<strong>FILE_WRITE_DATA</strong> access to the file.</p>
</blockquote>
<p>Once the information about the file has been returned, the caller can
determine how much information was actually returned by examining the
<em>Information</em> field of the <em>IoStatusBlock</em> variable.</p>
<h3 id="changing-information-about-a-file">Changing Information about a
File</h3>
<p>The information about a file may be changed using the
<strong>NtSetInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtSetInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PVOID</strong> <em>FileInformation,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN FILE_INFORMATION_CLASS</strong>
<em>FileInformationClass</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>FileInformation</em> - A pointer to a buffer that contains the
information about the file to be changed. The contents of this buffer
are defined by the <em>FileInformationClass</em> parameter described
below.</p>
<p><em>Length</em> - The length of the <em>FileInformation</em> buffer
in bytes.</p>
<p><em>FileInformationClass</em> - Specifies the type of information
that is contained in the <em>FileInformation</em> buffer. The type of
information in the buffer is defined by the following type codes.</p>
<p><strong><u>FileInformationClass Values</u></strong></p>
<p><em>FileBasicInformation</em> - Changes the basic information about
the specified file. <strong>FILE_WRITE_ATTRIBUTES</strong> access to the
file is required to perform this operation.</p>
<p><em>FileRenameInformation</em> - Specifies that the name of the file
should be changed to a new name. The caller must be able to remove the
directory entry for the file in the current directory and therefore
<strong>DELETE</strong> access is required to the file. The caller must
also be able to write to the new parent directory. See the notes below
for further information.</p>
<p><em>FileLinkInformation</em> - Specifies that a new link be added for
the file. The caller must be able to write to the new directory file.
See the notes below for further information.</p>
<p><em>FileDispositionInformation</em> - Specifies that the file should
be marked for delete. Once all of the handles to the file have been
closed, if the link count for the file is zero, then the file is
deleted. Even if the link count is nonzero, at least the directory entry
will be deleted. <strong>DELETE</strong> access to the file is required
to perform this operation. Also see the <strong>NtDeleteFile</strong>
service description.</p>
<p><em>FilePositionInformation</em> - Specifies a new byte offset as the
current position in the file. <strong>FILE_READ_DATA</strong> or
<strong>FILE_WRITE_DATA</strong> access to the file is required to
perform this operation. The file must also have been opened or created
using one of the synchronous I/O options.</p>
<p><em>FileModeInformation</em> - Specifies that a new mode for the
specified handle be set. See the notes below for further
information.</p>
<p><em>FileAllocationInformation</em> - Truncates or extends the
allocated size of the file. <strong>FILE_WRITE_DATA</strong> access to
the file is required to perform this operation. Note that truncating the
allocation size of the file may affect the end of file mark for the file
as well.</p>
<p><em>FileEndOfFileInformation</em> - Truncates or extends the amount
of valid data in the file by moving the current end of file.
<strong>FILE_WRITE_DATA</strong> access to the file is required to
perform this operation.</p>
<p><em>FileCopyOnWrite</em> - Links two streams together until such time
as one is written. No specific access right is required to set this
information on the file; that is, it is possible to change this
information about the file as long as the caller has a valid handle.</p>
<p><em>FileCompletionInformation</em> - Associates an I/O completion
object with the specified file object. This allows synchronization of
I/O request completions through the use of an I/O completion object.</p>
<p><em>FileMoveClusterInformation</em> - Moves data from one file to the
end of another file. <strong>FILE_WRITE_DATA</strong> access to the file
is required to peform this operation</p>
<p><em>FileOleClassIdInformation</em> - Sets the OLE class ID for the
file. <strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is
required to perform this operation.</p>
<p><em>FileOleStateBitsInformation</em> - Sets the OLE state bits for
the file. <strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is
required to perform this operation.</p>
<p><em>FileApplicationExplorableInformation</em> - Changes the
application view of whether or not the object is explorable.
<strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required to
perform this operation.</p>
<p><em>FileApplicationExplorableChildrenInformation</em> - Changes the
application view of whether or not the object has explorable children.
<strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required to
perform this operation.</p>
<p><em>FileObjectIdInformation</em> - Changes the object ID for the
file. <strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is
required to perform this operation.</p>
<p><em>FileContextIndexInformation</em> - Changes whether or not the
file is to be content indexed. <strong>FILE_WRITE_ATTRIBUTES</strong>
access to the file is required to perform this operation.</p>
<p><em>FileInheritContentIndexInformation</em> - Changes whether or not
the children of this file are to be content indexed.
<strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required to
perform this operation.</p>
<p><em>FileOleInformation</em> - Change the OLE information about the
file. <strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is
required to perform this operation.</p>
</blockquote>
<p>The <strong>NtSetInformationFile</strong> service changes information
about a file. The information in the buffer is defined by the following
type and structure. Note that the fields that are not supported for a
given device or file system are ignored. For example, the FAT file
system does not support a creation time, so this field is ignored on an
<strong>NtSetInformationFile</strong> service call.</p>
<p><strong><u>FileInformation Format by File Information
Class</u></strong></p>
<p><em>FileBasicInformation</em> - Data type is
<em>FILE_BASIC_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_BASIC_INFORMATION {</p>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>ULONG FileAttributes;</p>
<p>} FILE_BASIC_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p>All dates and times are specified in the standard <strong>Windows
NT</strong> system time format.</p>
<p>The file attributes field can be a combination of the following
values:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<p>Note that the <strong>FILE_ATTRIBUTE_NORMAL</strong> attribute is
overridden by all other file attributes flags.</p>
<p>If a field is set to zero, <strong>NtSetInformationFile</strong> does
not change the information about the file for that field.</p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation.</p>
</blockquote>
<p><em>FileRenameInformation</em> - Data type is
<em>FILE_RENAME_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_RENAME_INFORMATION {</p>
<p>BOOLEAN ReplaceIfExists;</p>
<p>HANDLE RootDirectory;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_RENAME_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>ReplaceIfExists</strong> Replace target file if it exists;
else fail</p>
<p><strong>RootDirectory</strong> Root directory of target file name</p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>This operation requires <strong>DELETE</strong> access to the current
file so that the directory entry may be removed from the current parent
directory. The caller must also have the appropriate access to create
the new entry in the new parent directory file.</p>
<p>The file name may be specified in one of three different ways. No
wildcards may ever be specified.</p>
<p>o - A simple file name. For this case, the file is simply renamed
within the same directory. That is, the name of the file changes but not
its location.</p>
<p>o - A fully qualified file name. In this case, the file changes not
only its name but its location as well.</p>
<p>o - A relative file name. In this case, the <em>RootDirectory</em>
field contains a handle to the target directory for the rename
operation. The file name itself must be a simple file name.</p>
</blockquote>
<p><em>FileDispositionInformation</em> - Data type is
<em>FILE_DISPOSITION_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_DISPOSITION_INFORMATION {</p>
<p>BOOLEAN DeleteFile;</p>
<p>} FILE_DISPOSITION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>DeleteFile</strong> Delete the file on close</p>
<p><strong>DELETE</strong> access to the file is required to perform
this operation.</p>
</blockquote>
<p><strong>It should be noted that if the file is deleted, the only
legal subsequent operation on the file through the open file handle is
to close the file using the NtClose system service.</strong></p>
<blockquote>
<p>Also see the <strong>NtDeleteFile</strong> service description.</p>
</blockquote>
<p><em>FileLinkInformation</em> - Data type is
<em>FILE_NAME_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_NAME_INFORMATION {</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_NAME_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>No specific access to the file is required to add a link to the file,
the file must simply be open. However, the caller must be able to create
the new link in the specified target directory.</p>
<p>The file name must be a fully qualified file specification.</p>
</blockquote>
<p><em>FilePositionInformation</em> - Data type is
<em>FILE_POSITION_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_POSITION_INFORMATION {</p>
<p>LARGE_INTEGER CurrentByteOffset;</p>
<p>} FILE_POSITION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CurrentByteOffset</strong> Current byte offset within the
file</p>
<p>If the file was opened or created with no intermediate buffering,
then the new value of the byte offset must be an integral number of 512
bytes.</p>
<p><strong>FILE_READ_DATA</strong> or <strong>FILE_WRITE_DATA</strong>
access to the file is required to change this information about the
file, and the file must be opened for synchronous I/O.</p>
</blockquote>
<p><em>FileModeInformation</em> - Data type is
<em>FILE_MODE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_MODE_INFORMATION {</p>
<p>ULONG Mode;</p>
<p>} FILE_MODE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>Mode</strong> Current open mode of file handle to the
file</p>
<p>The mode flags that may be changed are as follows:</p>
<p><strong>FILE_WRITE_THROUGH</strong></p>
<p><strong>FILE_SEQUENTIAL_ONLY</strong></p>
<p><strong>FILE_SYNCHRONOUS_IO_ALERT</strong></p>
<p><strong>FILE_SYNCHRONOUS_IO_NONALERT</strong></p>
<p>Note that it is only possible to switch between the two different
types of synchronous I/O. It is not possible to either switch to or from
synchronous I/O, nor is it possible to specify both types.</p>
<p>If the file has been opened with intermediate buffering disabled, the
<strong>FILE_WRITE_THROUGH</strong> flag cannot be turned off. That is,
it is forced on by the I/O system. This flag is ignored on a set
operation in this case.</p>
<p>Users should be aware that changing this information about the file
also changes the access mode for all handles referring to the same file
object. That is, all handles referring to the object that are duplicated
or inherited are also affected by this access change.</p>
<p>No specific access to the file is required to change this information
about the file; that is, this information is available as long as the
file is open.</p>
</blockquote>
<p><em>FileAllocationInformation</em> - Data type is
<em>FILE_ALLOCATION_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_ALLOCATION_INFORMATION {</p>
<p>LARGE_INTEGER AllocationSize;</p>
<p>} FILE_ALLOCATION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>AllocationSize</strong> The absolute allocation size of the
file in bytes</p>
<p><strong>FILE_WRITE_DATA</strong> access to the file is required to
perform this operation. Setting the allocation size of the file to some
number of bytes less than the current end of file mark causes the
current end of file mark to be moved to the end of the allocated size of
the file.</p>
</blockquote>
<p><em>FileEndOfFileInformation</em> - Data type is
<em>FILE_END_OF_FILE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_END_OF_FILE_INFORMATION {</p>
<p>LARGE_INTEGER EndOfFile;</p>
<p>} FILE_END_OF_FILE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>EndOfFile</strong> The absolute new end of file position</p>
<p>Extending the file beyond the current end of file causes pad bytes of
zeroes to be written to the new intermediate bytes.</p>
<p><strong>FILE_WRITE_DATA</strong> access to the file is required to
perform this operation.</p>
</blockquote>
<p><em>FileCopyOnWrite</em> - Data type is
<em>FILE_COPY_ON_WRITE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_COPY_ON_WRITE_INFORMATION {</p>
<p>BOOLEAN ReplaceIfExists;</p>
<p>HANDLE RootDirectory;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_COPY_ON_WRITE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>ReplaceIfExists</strong> Replace the target if it exists,
else fail</p>
<p><strong>RootDirectory</strong> Root directory of target file name</p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> Name of the file</p>
<p>No specific access to the file is required to change this information
about the file; that is, it is possible to change this information about
the file as long as the caller has a valid handle to the file.</p>
</blockquote>
<p><em>FileCompletionInformation</em> - Data type is
<em>FILE_COMPLETION_INFORMATION.</em></p>
<blockquote>
<p>typedef struct ­_FILE_COMPLETION_INFORMATION {</p>
<p>HANDLE Port;</p>
<p>ULONG Key;</p>
<p>} FILE_COMPLETION_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>Port</strong> Handle to the I/O completion object to
associate with the file</p>
<p><strong>Key</strong> Caller-defined value to be associated with this
completion object</p>
<p>No specific access to the file is required to change this information
about the file; that is, it is possible to change this information about
the file as long as the caller has a valid handle to the file.</p>
</blockquote>
<p><em>FileMoveClusterInformation</em> - Data type is
<em>FILE_MOVE_CLUSTER_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_MOVE_CLUSTER_INFORMATION {</p>
<p>ULONG ClusterCount;</p>
<p>HANDLE RootDirectory;</p>
<p>ULONG FileNameLength;</p>
<p>WCHAR FileName[];</p>
<p>} FILE_MOVE_CLUSTER_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>ClusterCount</strong> Count of clusters to be moved</p>
<p><strong>RootDirectory</strong> Root directory of target file name</p>
<p><strong>FileNameLength</strong> Length of the file name in bytes</p>
<p><strong>FileName</strong> File name of the target</p>
<p><strong>FILE_WRITE_DATA</strong> access to the file is required to
perform this operation. Setting the move cluster information on a file
causes moves <em>ClusterCount</em> clusters to the end of the specified
target file.</p>
</blockquote>
<p><em>FileOleClassIdInformation</em> - Data type is
<em>FILE_OLE_CLASS_ID_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_CLASS_ID_INFORMATION {</p>
<p>GUID ClassId;</p>
<p>} FILE_OLE_CLASS_ID_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>ClassId</strong> ID of the code that understands this file’s
format</p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the OLE class ID on a file changes
the association of application to the file.</p>
</blockquote>
<p><em>FileOleStateBitsInformation</em> - Data type is
<em>FILE_OLE_STATE_BITS_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_STATE_BITS_INFORMATION {</p>
<p>ULONG StateBits;</p>
<p>ULONG StateBitsMask;</p>
<p>} FILE_OLE_STATE_BITS_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>StateBits</strong> OLE state bit information</p>
<p><strong>StateBitsMask</strong> Mask to be applied to state bits</p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the OLE state bits on a file changes
the value of the file’s state bits. The state bits are treated as opaque
data to the file system with the exception of the
<em>FILE_ENABLE_DOCFILE_FORMAT</em> bit which causes a document file to
be treated as a single stream rather than as separately addressible
streams.</p>
</blockquote>
<p><em>FileApplicationExplorableInformation</em> - Data type is
<em>BOOLEAN.</em></p>
<blockquote>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the BOOLEAN flag indicates that the
application believes that the object represented by the file handle is
explorable.</p>
</blockquote>
<p><em>FileApplicationExplorableChildrenInformation</em> - Data type is
<em>BOOLEAN.</em></p>
<blockquote>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the BOOLEAN flag indicates that the
application believes that the object represented by the file handle has
explorable children.</p>
</blockquote>
<p><em>FileObjectIdInformation</em> - Data type is
<em>FILE_OBJECT_ID_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OBJECT_ID_INFORMATION {</p>
<p>OBJECTID ObjectId;</p>
<p>} FILE_OBJECT_ID_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>ObjectId</strong> Object ID for the file</p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the Object ID for a file changes the
unique ID for the file on the volume.</p>
</blockquote>
<p><em>FileContextIndexInformation</em> - Data type is
<em>BOOLEAN.</em></p>
<blockquote>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the BOOLEAN flag disables content
indexing for the file.</p>
</blockquote>
<p><em>FileInheritContentIndexInformation</em> - Data type is
<em>BOOLEAN.</em></p>
<blockquote>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation. Setting the BOOLEAN flag disables content
indexing for the children of the file.</p>
</blockquote>
<p><em>FileOleInformation</em> - Data type is
<em>FILE_OLE_INFORMATION.</em></p>
<blockquote>
<p>typedef struct _FILE_OLE_INFORMATION {</p>
<p>FILE_OLE_CLASSID_INFORMATION OleClassIdInformation;</p>
<p>FILE_OBJECTID_INFORMATION ObjectIdInformation;</p>
<p>FILE_STORAGE_TYPE StorageType;</p>
<p>ULONG OleStateBits;</p>
<p>BOOLEAN ApplicationIsExplorable;</p>
<p>BOOLEAN ApplicationHasExplorableChildren;</p>
<p>BOOLEAN ContentIndexDisable;</p>
<p>BOOLEAN InheritContentIndexDisable;</p>
<p>} FILE_OLE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>OleClassIdInformation</strong> OLE class ID for the file</p>
<p><strong>ObjectIdInformation</strong> Object ID for the file</p>
<p><strong>OleStateBits</strong> OLE state bits for file</p>
<p><strong>ApplicationIsExplorable</strong> Application-defined notion
of explorability</p>
<p><strong>ApplicationHasExplorableChildren</strong> Application-defined
notion of children’s explorability</p>
<p><strong>ContentIndexDisable</strong> Enable/disable content
indexing</p>
<p><strong>InheritContentIndexDisable</strong> Enable/disable content
indexing of children</p>
<p>The possible values for the storage type field are defined by the
<em>FILE_STORAGE_TYPE</em> enumerated type:</p>
<p>typedef enum _FILE_STORAGE_TYPE {</p>
<p>StorageTypeDirectory,</p>
<p>StorageTypeFile,</p>
<p>StorageTypeDocfile,</p>
<p>StorageTypeJunctionPoint,</p>
<p>StorageTypeCatalog,</p>
<p>StorageTypeStructuredStorage,</p>
<p>StorageTypeEmbedding,</p>
<p>StorageTypeStream</p>
<p>} FILE_STORAGE_TYPE;</p>
<p><strong>FILE_WRITE_ATTRIBUTES</strong> access to the file is required
to perform this operation.</p>
</blockquote>
<h3 id="obtaining-extended-attributes-for-a-file">Obtaining Extended
Attributes for a File</h3>
<p>The extended attributes for a file may be obtained using the
<strong>NtQueryEaFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryEaFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>Buffer,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN BOOLEAN</strong> <em>ReturnSingleEntry,</em></p>
<p><strong>IN PVOID</strong> <em>EaList</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>EaListLength,</em></p>
<p><strong>IN PULONG</strong> <em>EaIndex</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN BOOLEAN</strong> <em>RestartScan</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The length, in bytes, that
were written to the <em>Buffer</em> is returned in the
<em>Information</em> field of this variable. For more information about
this parameter see the <strong>NtCreateFile</strong> system service
description.</p>
<p><em>Buffer</em> - A pointer to a buffer to receive extended
attributes for the file.</p>
<p><em>Length</em> - The length of the specified buffer in bytes.</p>
<p><em>ReturnSingleEntry</em> - A BOOLEAN value that, if TRUE, indicates
that only a single entry should be returned.</p>
<p><em>EaList</em> - An optional list of extended attributes whose
name/value pair is returned in the <em>Buffer</em>. If this parameter is
supplied, only those EAs matching the names of the EAs in the list are
returned.</p>
<p><em>EaListLength</em> - Supplies the length of the <em>EaList</em>,
if one was specified. If no <em>EaList</em> was specified, this
parameter should be zero.</p>
<p><em>EaIndex</em> - An optional index to an EA whose name/value pair
is to be returned. The buffer is filled beginning with the EA associated
with the index value.</p>
<p><em>RestartScan</em> - A BOOLEAN value that indicates, if TRUE, that
the scan should be restarted from the beginning. This causes the query
operation to restart the scan from the beginning of the extended
attributes list.</p>
</blockquote>
<p>The <strong>NtQueryEaFile</strong> function obtains extended
attributes for the file represented by the file handle. Only complete
extended attribute name/value pairs are returned. No partial attribute,
such as only the name, is ever written into the buffer. The actual
number of EAs returned is the smallest of the following:</p>
<blockquote>
<p>o - One entry, if the <em>ReturnSingleEntry</em> parameter is
TRUE.</p>
<p>o - The number of EAs that fit into the specified buffer.</p>
<p>o - The number of EAs that exist, or the number of EAs that match the
list of EAs supplied by the optional <em>EaList</em> parameter.</p>
</blockquote>
<p><strong>NtQueryEaFile</strong> may be invoked multiple times to fill
the buffer with EAs from the file. It is possible that the EAs for the
file were modified between calls to get more EAs. Due to the sharing
semantics defined by OS/2, with which this API is compatible, it is not
possible to guarantee that the EAs were not modified.</p>
<p>If the optional <em>EaList</em> parameter is specified, then only the
information for those EAs specified in the list is returned. Further, if
this parameter is specified, then the <em>EaIndex</em> parameter is
ignored.</p>
<p>The <em>EaIndex</em> parameter may optionally be specified to return
EAs on the file beginning with an EA other than the first EA in the
list.</p>
<p>If multiple EAs are returned, then the structure for each EA in the
buffer will be aligned on a longword boundary. Each EA in the list
begins with a <em>NextEntryOffset</em> field that specifies the number
of bytes from the base of the current entry to the start of the next
entry. If there are no more entries following the current entry, then
the value of this field is zero.</p>
<p>The information that is returned in the <em>Buffer</em> is defined by
the following structure:</p>
<p>typedef struct _FILE_FULL_EA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>UCHAR Flags;</p>
<p>UCHAR EaNameLength;</p>
<p>USHORT EaValueLength;</p>
<p>CHAR EaName[];</p>
</blockquote>
<p>} FILE_FULL_EA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>Flags</strong> Flags to be associated with the EA</p>
<p><strong>EaNameLength</strong> Length of the EA's name field</p>
<p><strong>EaValueLength</strong> Length of the EA's value field</p>
<p><strong>EaName</strong> The name of the EA</p>
<p>The flags currently defined for EAs are:</p>
<p><strong>FILE_NEED_EA</strong></p>
<p>The value field begins after the end of the <em>EaName</em> field of
the structure, including a single null character. The null character is
not included in the <em>EaNameLength</em> field.</p>
<p>The value of the EA can be located then, by adding the length of the
EA name to the address of the <em>EaName</em> field, and adding one.</p>
<p>The type of the <em>EaList</em> parameter is defined by the following
structure:</p>
<p>typedef struct _FILE_GET_EA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>UCHAR EaNameLength;</p>
<p>CHAR EaName[];</p>
</blockquote>
<p>} FILE_GET_EA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>EaNameLength</strong> Length of the EA's name field</p>
<p><strong>EaName</strong> The name of the EA to be retrieved</p>
<p>The <em>NextEntryOffset</em> field, like its
<em>FILE_FULL_EA_INFORMATION</em> counterpart, is the offset in bytes
from the current entry in the list to the start of the next entry, if
there is one. If there are no more entries in the list, then the value
of this field is zero.</p>
<p>The <em>EaList</em> parameter defines the list of the EAs whose
information is to be returned. This selects a proper subset of the EAs
and only those EAs are returned.</p>
<p><strong>FILE_READ_EA</strong> access to the file is required in order
to obtain information about the extended attributes associated with the
file.</p>
<p>If an error, such as an invalid character is found in an EA name
field, is encountered, then the <em>Information</em> field in the I/O
status block contains the byte offset from the base of the
<em>Buffer</em> to the offending EA entry that caused the failure.</p>
<p>Once extended attributes for the file have been written to the
<em>Buffer</em>, the <em>Information</em> field of the
<em>IoStatusBlock</em> variable can be examined to determine how many
bytes of extended attributes information were actually returned.</p>
<h3 id="changing-extended-attributes-for-a-file">Changing Extended
Attributes for a File</h3>
<p>The extended attributes associated with a file may be changed using
the <strong>NtSetEaFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtSetEaFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PVOID</strong> <em>Buffer,</em></p>
<p><strong>IN ULONG</strong> <em>Length</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>Buffer</em> - A pointer to a buffer that contains the extended
attributes to be applied to the file.</p>
<p><em>Length</em> - The length of the specified buffer in bytes.</p>
</blockquote>
<p>The <strong>NtSetEaFile</strong> service changes the extended
attributes on the file using the EAs specified by the <em>Buffer</em>
parameter.</p>
<p>The information specified by the <em>Buffer</em> parameter is defined
by the following structure.</p>
<p>typedef struct _FILE_FULL_EA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>UCHAR Flags;</p>
<p>UCHAR EaNameLength;</p>
<p>USHORT EaValueLength;</p>
<p>CHAR EaName[];</p>
</blockquote>
<p>} FILE_FULL_EA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>Flags</strong> Flags to be associated with the EA</p>
<p><strong>EaNameLength</strong> Length of the EA's name field</p>
<p><strong>EaValueLength</strong> Length of the EA's value field</p>
<p><strong>EaName</strong> The name of the EA</p>
<p>The flags currently defined for EAs are:</p>
<p><strong>FILE_NEED_EA</strong></p>
<p>The value field begins after the end of the <em>EaName</em> field of
the structure, including a single null character. The null character is
not included in the <em>EaNameLength</em> field.</p>
<p>If multiple EAs are contained in the buffer, then the structure for
each entry is longword aligned. The <em>NextEntryOffset</em> field
contains the byte offset to the start of the next entry in the buffer.
If there are no more entries past the current entry, then this field is
zero.</p>
<p>EAs are applied to the file such that if the EA does not exist, then
it is added. If the EA does exist, it is replaced. An entry whose
<em>EaValueLength</em> field is zero indicates that the EA whose name
matches the entry is to be deleted from the list of EAs on the file.</p>
<p>If an error occurs changing the EAs on the file, then the
<em>Information</em> field in the I/O status block contains the byte
offset from the base of the <em>Buffer</em> to the offending EA entry
that caused the failure.</p>
<p><strong>FILE_WRITE_EA</strong> access to the file is required in
order to change the extended attributes associated with the file.</p>
<h3 id="locking-byte-ranges-in-files">Locking Byte Ranges in Files</h3>
<p>A byte range within a file may be locked using the
<strong>NtLockFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtLockFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>ByteOffset,</em></p>
<p><strong>IN PLARGE_INTEGER</strong><em>Length,</em></p>
<p><strong>IN ULONG</strong> <em>Key,</em></p>
<p><strong>IN BOOLEAN</strong> <em>FailImmediately,</em></p>
<p><strong>IN BOOLEAN</strong> <em>ExclusiveLock</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>ByteOffset</em> - Specifies the starting byte offset of the file
where the lock should begin.</p>
<p><em>Length</em> - The length of the byte range to lock, in bytes.</p>
<p><em>Key</em> - A value to be associated with the lock range for
further identification.</p>
<p><em>FailImmediately</em> - A BOOLEAN value that indicates whether the
service will return immediately if the lock cannot be obtained (TRUE),
or whether the service will wait indefinitely until the lock is acquired
(FALSE).</p>
<p><em>ExclusiveLock</em> - A BOOLEAN value that indicates the type of
lock that is applied to the byte range. If the value is TRUE, then the
lock is <em>exclusive</em>; otherwise, the lock is <em>shared</em>.</p>
</blockquote>
<p>The <strong>NtLockFile</strong> service is used to lock the specified
byte range for the file. The range locked is for the specified file, and
is controlled by the following:</p>
<blockquote>
<p>o - the <em>ByteOffset</em> of the file</p>
<p>o - the <em>Length</em> of the byte range</p>
<p>o - the <em>Key</em> value associated with the byte range</p>
<p>o - the invoking process</p>
</blockquote>
<p>Locks are not inherited by child processes when they are created.
They are owned by the process that acquired the lock. Locks may be
manipulated and "owned" by separate threads within a process as
thread-specific locks by specifying non-zero values for the <em>Key</em>
parameter in each thread.</p>
<p>There are two types of locks on files, shared and exclusive. A shared
lock allows read-only access by any process attempting to read the
locked range, including the owning process. Shared locks may also
overlap. Exclusive locks allow read/write access by only the owning
process and by access to any other process. Exclusive locks may not
overlap either shared locks or other exclusive locks.</p>
<p>Locks owned by a given process are unlocked once all of the handles
to the specified file have been closed by that process. The locks are
not released in any particular order.</p>
<p>It is not an error to specify a range that either spans or even
begins after the end of the file. These types of locks can be used to
synchronize access to the end of the file or for appending data to the
file.</p>
<p><strong>FILE_READ_DATA</strong> or <strong>FILE_WRITE_DATA</strong>
access is required to the file to request a lock.</p>
<h3 id="unlocking-byte-ranges-in-files">Unlocking Byte Ranges in
Files</h3>
<p>A byte range within a file may be unlocked using the
<strong>NtUnlockFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtUnlockFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>ByteOffset,</em></p>
<p><strong>IN PLARGE_INTEGER</strong> <em>Length,</em></p>
<p><strong>IN ULONG</strong> <em>Key</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>ByteOffset</em> - The byte offset of the file whose corresponding
lock is released. This value must exactly match the byte offset of the
lock.</p>
<p><em>Length</em> - The length of the locked byte range that is
released. This value must exactly match the length of the lock.</p>
<p><em>Key</em> - The value associated with the lock range for further
identification. This value must exactly match the key of the lock.</p>
</blockquote>
<p>The <strong>NtUnlockFile</strong> service is used to unlock the
specified byte range for the file. The lock parameters must exactly
match those of the acquired lock. If the parameters exactly match those
of the locked range, then the lock is released.</p>
<p>Only the process that owns the lock may unlock the byte range.</p>
<h2 id="file-system-services">File System Services</h2>
<p>This section presents those services that obtain information about
file systems and control them.</p>
<p>The APIs that perform these functions are as follows:</p>
<blockquote>
<p><strong>NtQueryVolumeInformationFile</strong> - Obtain information
about a file system volume.</p>
<p><strong>NtSetVolumeInformationFile</strong> - Change information
about a file system volume.</p>
<p><strong>NtQueryQuotaInformationFile</strong> Obtain quota information
about a file system volume.</p>
<p><strong>NtSetQuotaInformationFile</strong> - Change quota information
about a file system volume.</p>
<p><strong>NtFsControlFile</strong> - General file system control
interface.</p>
</blockquote>
<h3 id="obtaining-information-about-a-file-system-volume">Obtaining
Information about a File System Volume</h3>
<p>Information about a file system volume may be obtained using the
<strong>NtQueryVolumeInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryVolumeInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>OUT PVOID</strong> <em>FsInformation,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN FS_INFORMATION_CLASS</strong>
<em>FsInformationClass</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open file, device, directory, or
volume for which volume information is returned.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. The length, in bytes, of the
data written to the <em>FsInformation</em> buffer is returned in the
<em>Information</em> field of this variable. For more information about
this parameter see the <strong>NtCreateFile</strong> system service
description.</p>
<p><em>FsInformation</em> - A pointer to a buffer to receive information
about the specified volume. The contents of this buffer are defined by
the <em>FsInformationClass</em> parameter described below.</p>
<p><em>Length</em> - The length of the <em>FsInformation</em> buffer in
bytes.</p>
<p><em>FsInformationClass</em> - Specifies the type of information that
should be returned about the volume. The information in the
<em>FsInformation</em> buffer is defined by the following type
codes.</p>
<p><strong><u>FsInformationClass Values</u></strong></p>
<p><em>FileFsVolumeInformation</em> - Returns information about the
volume that is currently "mounted" on the specified device. No specific
access to the volume is required to obtain this information.</p>
<p><em>FileFsSizeInformation</em> - Returns information about the size
and the free space on the volume. No specific access to the volume is
required to obtain this information.</p>
<p><em>FileFsDeviceInformation</em> - Returns information about the
device upon which the volume is actually mounted, or the device to which
the handle directly refers. No specific access to the volume is required
to obtain this information.</p>
<p><em>FileFsAttributeInformation</em> - Returns attribute information
about the file system responsible for the volume. No specific access to
the volume is required to obtain this information.</p>
<p><em>FileFsControlInformation</em> - Returns file system control
information about the volume. No specific access to the volume is
require to obtain this information.</p>
</blockquote>
<p>The <strong>NtQueryVolumeInformationFile</strong> service returns
information about the volume specified by the <em>FileHandle</em>
parameter. The information returned in the buffer is defined by the
following type codes and structures.</p>
<p><strong><u>FsInformation Format by Fs Information
Class</u></strong></p>
<p><em>FileFsVolumeInformation</em> - Data type is
<em>FILE_FS_VOLUME_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FS_VOLUME_INFORMATION {</p>
<p>LARGE_INTEGER VolumeCreationTime;</p>
<p>ULONG VolumeSerialNumber;</p>
<p>ULONG VolumeLabelLength;</p>
<p>BOOLEAN SupportsObjects;</p>
<p>WCHAR VolumeLabel[];</p>
<p>} FILE_FS_VOLUME_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>VolumeCreationTime</strong> Date/time the volume was
created</p>
<p><strong>VolumeSerialNumber</strong> Serial number of the volume</p>
<p><strong>VolumeLabelLength</strong> Length of the name of the
volume</p>
<p><strong>SupportsObjects</strong> File system supports object-oriented
file system objects</p>
<p><strong>VolumeLabel</strong> Name of the volume</p>
<p>No specific access to the volume is required to obtain this
information about the volume; that is, this information is available as
long as the volume is accessed through an open handle to the volume or
device itself, or to a file or directory on the volume.</p>
</blockquote>
<p><em>FileFsSizeInformation</em> - Data type is
<em>FILE_FS_SIZE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FS_SIZE_INFORMATION {</p>
<p>LARGE_INTEGER TotalAllocationUnits;</p>
<p>LARGE_INTEGER AvailableAllocationUnits;</p>
<p>ULONG SectorsPerAllocationUnit;</p>
<p>ULONG BytesPerSector;</p>
<p>} FILE_FS_SIZE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>TotalAllocationUnits</strong> Total allocation units on
volume</p>
<p><strong>AvailableAllocationUnits</strong> Free allocation units on
volume</p>
<p><strong>SectorsPerAllocationUnit</strong> Number of sectors in each
allocation unit</p>
<p><strong>BytesPerSector</strong> Number of bytes in each sector</p>
<p>No specific access to the volume is required to obtain this
information about the volume; that is, this information is available as
long as the volume is accessed through an open handle to the volume or
device itself, or to a file or directory on the volume.</p>
</blockquote>
<p><em>FileFsDeviceInformation</em> - Data type is
<em>FILE_FS_DEVICE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FS_DEVICE_INFORMATION {</p>
<p>DEVICE_TYPE DeviceType;</p>
<p>ULONG Characteristics;</p>
<p>} FILE_FS_DEVICE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>DeviceType</strong> Type of the target device</p>
<p><strong>Characteristics</strong> Characteristcs of the target
device</p>
<p>Device types have the following valid values:</p>
<p><strong>FILE_DEVICE_BATTERY</strong></p>
<p><strong>FILE_DEVICE_BEEP</strong></p>
<p><strong>FILE_DEVICE_BUS_EXTENDER</strong></p>
<p><strong>FILE_DEVICE_CD_ROM</strong></p>
<p><strong>FILE_DEVICE_CD_ROM_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_CONTROLLER</strong></p>
<p><strong>FILE_DEVICE_DATALINK</strong></p>
<p><strong>FILE_DEVICE_DFS</strong></p>
<p><strong>FILE_DEVICE_DISK</strong></p>
<p><strong>FILE_DEVICE_DISK_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_INPORT_PORT</strong></p>
<p><strong>FILE_DEVICE_KEYBOARD</strong></p>
<p><strong>FILE_DEVICE_MAILSLOT</strong></p>
<p><strong>FILE_DEVICE_MIDI_IN</strong></p>
<p><strong>FILE_DEVICE_MIDI_OUT</strong></p>
<p><strong>FILE_DEVICE_MOUSE</strong></p>
<p><strong>FILE_DEVICE_MULTI_UNC_PROVIDER</strong></p>
<p><strong>FILE_DEVICE_NAMED_PIPE</strong></p>
<p><strong>FILE_DEVICE_NETWORK</strong></p>
<p><strong>FILE_DEVICE_NETWORK_BROWSER</strong></p>
<p><strong>FILE_DEVICE_NETWORK_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_NETWORK_REDIRECTOR</strong></p>
<p><strong>FILE_DEVICE_NULL</strong></p>
<p><strong>FILE_DEVICE_PARALLEL_PORT</strong></p>
<p><strong>FILE_DEVICE_PHYSICAL_NETCARD</strong></p>
<p><strong>FILE_DEVICE_PRINTER</strong></p>
<p><strong>FILE_DEVICE_SCANNER</strong></p>
<p><strong>FILE_DEVICE_SCREEN</strong></p>
<p><strong>FILE_DEVICE_SERIAL_MOUSE_PORT</strong></p>
<p><strong>FILE_DEVICE_SERIAL_PORT</strong></p>
<p><strong>FILE_DEVICE_SOUND</strong></p>
<p><strong>FILE_DEVICE_STREAMS</strong></p>
<p><strong>FILE_DEVICE_TAPE</strong></p>
<p><strong>FILE_DEVICE_TAPE_FILE_SYSTEM</strong></p>
<p><strong>FILE_DEVICE_TRANSPORT</strong></p>
<p><strong>FILE_DEVICE_UNKNOWN</strong></p>
<p><strong>FILE_DEVICE_VIDEO</strong></p>
<p><strong>FILE_DEVICE_VIRTUAL_DISK</strong></p>
<p><strong>FILE_DEVICE_WAVE_IN</strong></p>
<p><strong>FILE_DEVICE_WAVE_OUT</strong></p>
<p><strong>FILE_DEVICE_8042_PORT</strong></p>
<p>Device characteristics have the following valid flags:</p>
<p><strong><u>Flag Meaning</u></strong></p>
<p><strong>FILE_REMOVABLE_MEDIA</strong> Device supports removable
media</p>
<p><strong>FILE_READ_ONLY_DEVICE</strong> Device is a read-only
device</p>
<p><strong>FILE_FLOPPY_DISKETTE</strong> Media in device is a floppy
diskette</p>
<p><strong>FILE_WRITE_ONCE_MEDIA</strong> Device supports write once
media</p>
<p><strong>FILE_REMOTE_DEVICE</strong> Device is a remote device</p>
<p><strong>FILE_DEVICE_IS_MOUNTED</strong> Device is currently
mounted</p>
<p><strong>FILE_VIRTUAL_VOLUME</strong> Device volume is virtual</p>
<p>No specific access to the volume is required to obtain this
information about the volume; that is, this information is available as
long as the volume is accessed through an open handle to the volume or
device itself, or to a file or directory on the volume.</p>
</blockquote>
<p><em>FileFsAttributeInformation</em> - Data type is
<em>FILE_FS_ATTRIBUTE_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {</p>
<p>ULONG FileSystemAttributes;</p>
<p>LONG MaximumComponentNameLength;</p>
<p>ULONG FileSystemNameLength;</p>
<p>WCHAR FileSystemName;</p>
<p>} FILE_FS_ATTRIBUTE_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FileSystemAttributes</strong> Attributes of the volume's
owning file system</p>
<p><strong>MaximumComponentNameLength</strong> Maximum length of each
file name component</p>
<p><strong>FileSystemNameLength</strong> The length of the file system's
name</p>
<p><strong>FileSystemName</strong> The name of the file system</p>
<p>File system attributes have the following valid flags:</p>
<p><strong><u>Flag Meaning</u></strong></p>
<p><strong>FILE_CASE_SENSITIVE_SEARCH</strong> Supports case sensitive
searches</p>
<p><strong>FILE_CASE_PRESERVED_NAMES</strong> Supports preserving name
case on disk</p>
<p><strong>FILE_UNICODE_ON_DISK</strong> Stores UNICODE characters on
disk</p>
<p><strong>FILE_PERSISTENT_ACLS</strong> Stores ACLs on disk</p>
<p><strong>FILE_FILE_COMPRESSION</strong> Supports file compression</p>
<p><strong>FILE_VOLUME_IS_COMPRESSED</strong> Handle refers to a
compressed volume</p>
<p>No specific access to the volume is required to obtain this
information about the volume; that is, this information is available as
long as the volume is accessed through an open handle to the volume or
device itself, or to a file or directory on the volume.</p>
</blockquote>
<p><em>FileFsControlInformation</em> - Data type is
<em>FILE_FS_CONTROL_INFORMATION {</em></p>
<blockquote>
<p>typedef struct ­_FILE_FS_CONTROL_INFORMATION {</p>
<p>LARGE_INTEGER FreeSpaceStartFiltering;</p>
<p>LARGE_INTEGER FreeSpaceThreshold;</p>
<p>LARGE_INTEGER FreeSpaceStopFiltering;</p>
<p>LARGE_INTEGER DefaultQuotaThreshold;</p>
<p>LARGE_INTEGER DefaultQuotaLimit;</p>
<p>LARGE_INTEGER DeletionLogSizeLimit;</p>
<p>ULONG FileSystemControlFlags;</p>
<p>} FILE_FS_CONTROL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FreeSpaceStartFiltering</strong> Amount of space required to
begin content indexing</p>
<p><strong>FreeSpaceThreshold</strong> Amount of space remaining to
generate popup</p>
<p><strong>FreeSpaceStopFiltering</strong> Amount of space remaining to
stop content indexing</p>
<p><strong>DefaultQuotaThreshold</strong> Default quota threshold for
volume</p>
<p><strong>DefaultQuotaLimit</strong> Default quota limit for volume</p>
<p><strong>DeletionLogSizeLimit</strong> Size of deletion file log</p>
<p><strong>FileSystemControlFlags</strong> Flags to control this
volume</p>
<p>File system control flags consist of the following valid flag
values:</p>
<p><strong><u>Flag Meaning</u></strong></p>
<p><strong>FILE_VC_QUOTA_NONE</strong> No quota information
maintained</p>
<p><strong>FILE_VC_QUOTA_TRACK</strong> Quotas are being tracked on
volume</p>
<p><strong>FILE_VC_QUOTA_ENFORCE</strong> Quotas are being enforced on
volume</p>
<p><strong>FILE_VC_QUOTAS_INCOMPLETE</strong> Volume quotas are
incomplete</p>
<p><strong>FILE_VC_CONTENT_INDEX_DISABLED</strong> Content indexing
disabled</p>
<p><strong>FILE_VC_LOG_QUOTA_THRESHOLD</strong> Log quota threshold
reached event</p>
<p><strong>FILE_VC_LOG_QUOTA_LIMIT</strong> Log quota limit reached
event</p>
<p><strong>FILE_VC_LOG_VOLUME_THRESHOLD</strong> Log volume free space
threshold event</p>
<p><strong>FILE_VC_LOG_VOLUME_LIMIT</strong> Log volume free space limit
event</p>
<p>No specific access to the volume is required to obtain this
information about the volume; that is, this information is available as
long as the volume is accessed through an open handle to the volume or
device itself, or to a file or directory on the volume.</p>
</blockquote>
<p>Once the information about the volume has been returned, the
<em>Information</em> field of the <em>IoStatusBlock</em> variable can be
examined to determine the number of bytes of volume information actually
written to the <em>FsInformation</em> buffer.</p>
<h3 id="changing-information-about-a-file-system-volume">Changing
Information about a File System Volume</h3>
<p>Information about a file system volume may be changed using the
<strong>NtSetVolumeInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtSetVolumeInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN PVOID</strong> <em>FsInformation,</em></p>
<p><strong>IN ULONG</strong> <em>Length,</em></p>
<p><strong>IN FS_INFORMATION_CLASS</strong>
<em>FsInformationClass</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to an open volume for which
information is changed.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>FsInformation</em> - A pointer to a buffer that contains the
information about the file system to be changed. The contents of this
buffer are defined by the <em>FsInformationClass</em> parameter
described below.</p>
<p><em>Length</em> - The length of the <em>FsInformation</em> buffer in
bytes.</p>
<p><em>FsInformationClass</em> - Specifies the type of information that
should be changed about the file system. The information in the
<em>FsInformation</em> buffer is defined by the following type
codes.</p>
<p><strong><u>FsInformationClass Values</u></strong></p>
<p><em>FileFsLabelInformation</em> - Changes the volume label on the
volume that is currently "mounted" on the specified device.
<strong>FILE_WRITE_DATA</strong> access to the device or volume is
required.</p>
<p><em>FileFsControlInformation</em> - Changes the file system control
information for the volume that is currently “mounted” on the specified
device. <strong>FILE_WRITE_DATA</strong> access to the device or volume
is required.</p>
</blockquote>
<p>The <strong>NtSetVolumeInformationFile</strong> service changes
information about the volume "mounted" on the device specified by the
<em>FileHandle</em> parameter. The information to be changed is in the
<em>FsInformation</em> buffer. Its contents are defined by the following
type codes and structures.</p>
<p><strong><u>FsInformation Format by Fs Information
Class</u></strong></p>
<p><em>FileFsLabelInformation</em> - Data type is
<em>FILE_FS_LABEL_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _FILE_FS_LABEL_INFORMATION {</p>
<p>ULONG VolumeLabelLength;</p>
<p>WCHAR VolumeLabel[];</p>
<p>} FILE_FS_LABEL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>VolumeLabelLength</strong> Length of the name of the
volume</p>
<p><strong>VolumeLabel</strong> Name of the volume</p>
<p><strong>FILE_WRITE_DATA</strong> access to the device or volume is
required to change this information.</p>
</blockquote>
<p><em>FileFsControlInformation</em> - Data type is
<em>FILE_FS_CONTROL_INFORMATION {</em></p>
<blockquote>
<p>typedef struct ­_FILE_FS_CONTROL_INFORMATION {</p>
<p>LARGE_INTEGER FreeSpaceStartFiltering;</p>
<p>LARGE_INTEGER FreeSpaceThreshold;</p>
<p>LARGE_INTEGER FreeSpaceStopFiltering;</p>
<p>LARGE_INTEGER DefaultQuotaThreshold;</p>
<p>LARGE_INTEGER DefaultQuotaLimit;</p>
<p>LARGE_INTEGER DeletionLogSizeLimit;</p>
<p>ULONG FileSystemControlFlags;</p>
<p>} FILE_FS_CONTROL_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>FreeSpaceStartFiltering</strong> Amount of space required to
begin content indexing</p>
<p><strong>FreeSpaceThreshold</strong> Amount of space remaining to
generate popup</p>
<p><strong>FreeSpaceStopFiltering</strong> Amount of space remaining to
stop content indexing</p>
<p><strong>DefaultQuotaThreshold</strong> Default quota threshold for
volume</p>
<p><strong>DefaultQuotaLimit</strong> Default quota limit for volume</p>
<p><strong>DeletionLogSizeLimit</strong> Size of deletion file log</p>
<p><strong>FileSystemControlFlags</strong> Flags to control this
volume</p>
<p>File system control flags consist of the following valid flag
values:</p>
<p><strong><u>Flag Meaning</u></strong></p>
<p><strong>FILE_VC_QUOTA_NONE</strong> No quota information
maintained</p>
<p><strong>FILE_VC_QUOTA_TRACK</strong> Quotas are being tracked on
volume</p>
<p><strong>FILE_VC_QUOTA_ENFORCE</strong> Quotas are being enforced on
volume</p>
<p><strong>FILE_VC_QUOTAS_INCOMPLETE</strong> Volume quotas are
incomplete</p>
<p><strong>FILE_VC_CONTENT_INDEX_DISABLED</strong> Content indexing
disabled</p>
<p><strong>FILE_VC_LOG_QUOTA_THRESHOLD</strong> Log quota threshold
reached event</p>
<p><strong>FILE_VC_LOG_QUOTA_LIMIT</strong> Log quota limit reached
event</p>
<p><strong>FILE_VC_LOG_VOLUME_THRESHOLD</strong> Log volume free space
threshold event</p>
<p><strong>FILE_VC_LOG_VOLUME_LIMIT</strong> Log volume free space limit
event</p>
<p><strong>FILE_WRITE_DATA</strong> access to the volume is required in
order to change the file system control information.</p>
</blockquote>
<h3
id="obtaining-quota-information-about-a-file-system-volume">Obtaining
Quota Information about a File System Volume</h3>
<p>Quota information about a file system volume may be obtained using
the <strong>NtQueryQuotaInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryQuotaInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle</em>,</p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em>,</p>
<p><strong>OUT PVOID</strong> <em>Buffer</em>,</p>
<p><strong>IN ULONG</strong> <em>Length</em>,</p>
<p><strong>IN BOOLEAN</strong> <em>ReturnSingleEntry</em>,</p>
<p><strong>IN PVOID</strong> <em>SidList</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>IN ULONG</strong> <em>SidListLength</em>,</p>
<p><strong>IN PSID</strong> <em>StartSid</em>
<strong>OPTIONAL</strong>,</p>
<p><strong>IN BOOLEAN</strong> <em>RestartScan</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open handle to an open file, directory,
device, or volume whose quota information is to be returned.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. Service calls that return
information, return the length of the data written to the output buffer
in the <em>Information</em> field of this variable. For more information
about this parameter see the <strong>NtCreateFile</strong> system
service description.</p>
<p><em>Buffer</em> - A pointer to a buffer to receive the requested
quota information about the specified volume.</p>
<p><em>Length</em> - Specifies the length of the <em>Buffer</em>
parameter in bytes.</p>
<p><em>ReturnSingleEntry</em> - A BOOLEAN value that, if TRUE, indicates
that only a single quota entry should be returned.</p>
<p><em>SidList</em> - An optional list of entries whose quota entries
are returned in the <em>Buffer</em>. If this parameter is supplied, only
those quota entries matching the SIDs in the list are returned.</p>
<p><em>SidListLength</em> - Supplies the length of the <em>SidList</em>,
if one was specified. If no <em>SidList</em> was specified, this
parameter should be zero.</p>
<p><em>StartSid</em> - An optional SID that specifies a quota entry to
be rewound to during a <em>RestartScan</em> operation. The first quota
entry returned is the entry following the entry specified by the
SID.</p>
<p><em>RestartScan</em> - A BOOLEAN value that, if TRUE, indicates that
the scan should be restarted from the beginning, or alternately from the
entry following the <em>StartSid</em> entry. This causes the query to
restart the scan from the beginning or from the entry following the
quota entry for the specified SID.</p>
</blockquote>
<p>The <strong>NtQueryQuotaInformationFile</strong> function obtains
quota entry information for the volume represented by the file handle.
Only complete quota entries are returned. The actual number of quota
entries returned is the smallest of the following:</p>
<blockquote>
<p>o - One entry, if the <em>ReturnSingleEntry</em> parameter is
TRUE.</p>
<p>o - One entry, if the only entry visible is the entry for the current
thread’s SID.</p>
<p>o - The number of quota entries that fit into the specified
buffer.</p>
<p>o - The number of quota entries that exist, or the number of entries
that match the list of entries supplied by the optional <em>SidList</em>
parameter.</p>
</blockquote>
<p><strong>NtQueryQuotaInformationFile</strong> may be invoked multiple
times to fill the buffer with quota entries for the volume. It is
possible that the quota entries for the volume were modified between
calls to get more entries, unless the volume is locked.</p>
<p>If the optional <em>SidList</em> parameter is specified, then only
the quota information for those SIDs specified in the list is returned.
Specifying a SID which has no corresponding quota information on the
volume causes an entry to be returned with all zeroes for the quota
fields. Futher, if this parameter is specified, then the
<em>StartSid</em> parameter is ignored. Finally, if a <em>SidList</em>
is specified, the output buffer will be filled with as many matching
entries as possible. If they do not fit, then the caller should invoke
the service again, changing the start of the list to the point where the
last service left off.</p>
<p>For example, if the caller passed in a <em>SidList</em> with entries
for SIDs A, B, C, D, and E, and the output buffer was only large enough
for the file system to return entries for SIDs A, B, and C, then the
caller should invoke the service again specifying SIDs D and E. Because
the list is self-describing, this can be easily accomplished by simply
changing the starting pointer and adjusting the <em>SidListLength</em>
parameter.</p>
<p>The <em>StartSid</em> parameter may optionally be specified to return
quota entries for the volume beginning with an entry other than the
first quota entry. If a <em>StartSid</em> is specified, and the
<em>RestartScan</em> parameter is specified, then the quota entries
returned will be start with the quota entry for the entry after the one
selected by the <em>StartSid</em> parameter.</p>
<p>If multiple quota entries are returned, then the structure for each
entry in the buffer will be aligned on a longword boundary. Each entry
in the list begins with a <em>NextEntryOffset</em> field that specifies
the number of bytes from the base of the current entry to the start of
the next entry. If there are no more entries following the current
entry, then the value of this field is zero.</p>
<p>The format of the <em>SidList</em> information buffer is defined by
the following structure:</p>
<p>typedef struct ­­_FILE_GET_QUOTA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>ULONG SidLength;</p>
<p>SID Sid;</p>
</blockquote>
<p>} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>SidLength</strong> Length, in bytes, of the SID</p>
<p><strong>Sid</strong> SID of entry to be returned</p>
<p>No special access to the volume is required in order to obtain quota
information about the volume. The <em>FileHandle</em> may refer to
either the volume, or a file or directory anywhere on the volume to
which the caller has some access.</p>
<p>Once quota entries for the volume have been written to the
<em>Buffer</em>, the <em>Information</em> field of the
<em>IoStatusBlock</em> variable can be examined to determine how many
bytes of quota information were actually returned.</p>
<h3 id="changing-quota-information-about-a-file-system-volume">Changing
Quota Information about a File System Volume</h3>
<p>Quota information about a file system volume may be changed using the
<strong>NtSetQuotaInformationFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtSetQuotaInformationFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle</em>,</p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em>,</p>
<p><strong>IN PVOID</strong> <em>Buffer</em>,</p>
<p><strong>IN ULONG</strong> <em>Length</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - A handle to a volume whose quota entries are to
be changed.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
<p><em>Buffer</em> - A opinter to a buffer that contains the quota entry
information to be applied to the volume.</p>
<p><em>Length</em> - The length of the specified buffer in bytes.</p>
</blockquote>
<p>The <strong>NtSetQuotaInformationFile</strong> service changes the
quota information on a volume using the quota entries specified by the
<em>Buffer</em> parameter.</p>
<p>The information specified by the <em>Buffer</em> parameter is defined
by the following structure:</p>
<p>typedef struct ­­_FILE_QUOTA_INFORMATION {</p>
<blockquote>
<p>ULONG NextEntryOffset;</p>
<p>ULONG SidLength;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>LARGE_INTEGER QuotaUsed;</p>
<p>LARGE_INTEGER QuotaThreshold;</p>
<p>LARGE_INTEGER QuotaLimit;</p>
<p>SID Sid;</p>
</blockquote>
<p>} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>NextEntryOffset</strong> Offset, in bytes, to the next entry
in the list</p>
<p><strong>SidLength</strong> Length, in bytes, of the SID</p>
<p><strong>ChangeTime</strong> Time that the quota entry was last
changed</p>
<p><strong>QuotaUsed</strong> Amount of disk space used</p>
<p><strong>QuotaThreshold</strong> Amount of disk space useable without
incurring an event</p>
<p><strong>QuotaLimit</strong> Amount of disk space permitted to be
used</p>
<p><strong>Sid</strong> SID of this quota entry</p>
<p>If multiple quota entries are contained in the buffer, then the
structure for each entry is longword aligned. The
<em>NextEntryOffset</em> field contains the byte offset to the start of
the next entry in the buffer. If there are no more entries past the
current entry, then this field is zero.</p>
<p>If an error occurs changing the quotas on the volume, then the
<em>Information</em> field in the I/O status block contains the byte
offset from the vase of the <em>Buffer</em> to the offending quota entry
that caused the failure.</p>
<p><strong>FILE_WRITE_DATA</strong> access to the volume is required in
order to change the quota information associated with the volume.</p>
<h3 id="controlling-file-systems">Controlling File Systems</h3>
<p>Information may be passed between applications and file systems using
the <strong>NtFsControlFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtFsControlFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN ULONG</strong> <em>FsControlCode,</em></p>
<p><strong>IN PVOID</strong> <em>InputBuffer</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>InputBufferLength,</em></p>
<p><strong>OUT PVOID</strong> <em>OutputBuffer</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>OutputBufferLength</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to the file or device to
whose file system the control information should be given.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. Service calls that return
information, return the length of the data written to the output buffer
in the <em>Information</em> field of this variable. For more information
about this parameter see the <strong>NtCreateFile</strong> system
service description.</p>
<p><em>FsControlCode</em> - A code that indicates which file system
control function is to be executed.</p>
<p><em>InputBuffer</em> - An optional pointer to a buffer that contains
the information to be given to the target file system. This information
is file-system-specific.</p>
<p><em>InputBufferLength</em> - The length of the <em>InputBuffer</em>
in bytes. If the buffer is not supplied, then this value is ignored.</p>
<p><em>OutputBuffer</em> - An optional pointer to a buffer that is to
receive the file-system-dependent return information from the target
file system.</p>
<p><em>OutputBufferLength</em> - The length of the <em>OutputBuffer</em>
in bytes. If the buffer is not supplied, then this value is ignored.</p>
</blockquote>
<p>The <strong>NtFsControlFile</strong> service is a
file-system-dependent interface that extends the control that
applications have over various components within the system. This API
provides a consistent view of the input and output data to the system
while still providing the application and file system drivers a
file-system-dependent method of specifying a communications
interface.</p>
<p>The type of access that the caller needs to the file is dependent on
the actual operation being performed.</p>
<h2 id="miscellaneous-services">Miscellaneous Services</h2>
<p>This section presents those service that provide miscellaneous
functionality for files and devices.</p>
<p>The APIs that perform these functions are as follows:</p>
<blockquote>
<p><strong>NtFlushBuffersFile</strong> - Flushes all buffered and cached
data out to the file.</p>
<p><strong>NtCancelIoFile</strong> - Cancels all I/O operations on a
file.</p>
<p><strong>NtDeviceIoControlFile</strong> - Miscellaneous device
control.</p>
</blockquote>
<h3 id="flushing-file-buffers">Flushing File Buffers</h3>
<p>Buffered data may be flushed out to the file using the
<strong>NtFlushBuffersFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtFlushBuffersFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to a file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
</blockquote>
<p>The <strong>NtFlushBuffersFile</strong> service causes all buffered
data to be written to the file.</p>
<p><strong>FILE_WRITE_DATA</strong> or <strong>FILE_APPEND_DATA</strong>
access to the file is required to perform this service.</p>
<h3 id="canceling-pending-io-on-a-file">Canceling Pending I/O on a
File</h3>
<p>Pending I/O operations on a file may be canceled using the
<strong>NtCancelIoFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtCancelIoFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to a file.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status. For more information about this parameter see the
<strong>NtCreateFile</strong> system service description.</p>
</blockquote>
<p>The <strong>NtCancelIoFile</strong> service causes all pending I/O
for the specified file to be marked as canceled. Most types of
operations can be canceled immediately, while others may continue toward
completion before they are actually canceled. For example, once a DMA
disk drive has begun a transfer, the operation cannot be canceled by a
device driver, but to the caller it will appear as if the operation had
effectively been canceled.</p>
<p>Only those pending operations that were issued by the current thread
using the specified handle are canceled. Any operations issued for the
file by any other thread or any other process continues normally.</p>
<p>No specific access to the file is required in order to use this
service since the caller is only canceling those operations that he
requested in the first place.</p>
<p>All pending I/O operations complete with a status that indicates that
the operation was canceled.</p>
<h3 id="miscellaneous-io-control">Miscellaneous I/O Control</h3>
<p>Various operations may be performed on files to control the file, or
the device associated with the file, using the
<strong>NtDeviceIoControlFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtDeviceIoControlFile(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN HANDLE</strong> <em>Event</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PIO_APC_ROUTINE</strong> <em>ApcRoutine</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>
<strong>OPTIONAL,</strong></p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock,</em></p>
<p><strong>IN ULONG</strong> <em>IoControlCode,</em></p>
<p><strong>IN PVOID</strong> <em>InputBuffer</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>InputBufferLength,</em></p>
<p><strong>OUT PVOID</strong> <em>OutputBuffer</em>
<strong>OPTIONAL,</strong></p>
<p><strong>IN ULONG</strong> <em>OutputBufferLength</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>FileHandle</em> - An open file handle to the file or device to
which the control information should be given.</p>
<p><em>Event</em> - An optional handle to an event to be set to the
Signaled state when the operation completes.</p>
<p><em>ApcRoutine</em> - An optional procedure to be invoked once the
operation completes. For more information about this parameter see the
<strong>NtReadFile</strong> system service description.</p>
<p><em>ApcContext</em> - A pointer to pass as an argument to the
<em>ApcRoutine</em>, if one was specified, when the operation completes.
This argument is required if an <em>ApcRoutine</em> was specified.</p>
<p><em>IoStatusBlock</em> - A variable to receive the final completion
status and information about the operation. Service calls that return
information, return the length of the data written to the output buffer
in the <em>Information</em> field of this variable. For more information
about this parameter see the <strong>NtCreateFile</strong> system
service description.</p>
<p><em>IoControlCode</em> - A code that indicates which device I/O
control function is to be executed.</p>
<p><em>InputBuffer</em> - An optional pointer to a buffer that contains
the information to be given to the target device. This information is
device-dependent.</p>
<p><em>InputBufferLength</em> - The length of the <em>InputBuffer</em>
in bytes. If the buffer is not supplied, then this value is ignored.</p>
<p><em>OutputBuffer</em> - An optional pointer to a buffer that is to
receive the device-dependent return information from the target
device.</p>
<p><em>OutputBufferLength</em> - The length of the <em>OutputBuffer</em>
in bytes. If the buffer is not supplied, then this value is ignored.</p>
</blockquote>
<p>The <strong>NtDeviceIoControlFile</strong> service is a
device-dependent interface that extends the control that applications
have over various devices within the system. This API provides a
consistent view of the input and output data to the system while still
providing the application and the driver a device-dependent method of
specifying a communications interface.</p>
<p>The type of access that the caller needs to the file is dependent on
the actual operation being performed.</p>
<p>Once the service has completed, the <em>Event</em>, if specified,
will be set to the Signaled state. If no <em>Event</em> parameter was
specified, then the file object specified by the <em>FileHandle</em>
will be set to the Signaled state. If an <em>ApcRoutine</em> was
specified, it is invoked with the <em>ApcContext</em> and the address of
the <em>IoStatusBlock</em> as its arguments.</p>
<h3 id="deleting-a-file">Deleting a File</h3>
<p>A file can be deleted using the <strong>NtDeleteFile</strong>
service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtDeleteFile(</strong></p>
<blockquote>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of the file, a root directory, and a set of file object
attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the file to be deleted. This file specification must be a fully
qualified file specification or the name of a device, unless it is a
file relative to the directory specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the file
specified by the <em>ObjectName</em> field is a file specification
relative to the directory file supplied by this handle.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
</blockquote>
<p>The <strong>NtDeleteFile</strong> service allows the caller to delete
a file. <strong>DELETE</strong> access to the target file is required.
This service is equivalent to calling <strong>NtOpenFile,
NtSetInformationFile</strong> with a file information class of
<em>FileDispositionInformation</em>, and <strong>NtClose</strong>.
However, this service is faster because less ring transitions are
made.</p>
<h3 id="querying-the-attributes-of-a-file">Querying the Attributes of a
File</h3>
<p>The attributes of a file can be queried using the
<strong>NtQueryAttributesFile</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryAttributesFile(</strong></p>
<blockquote>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes</em>,</p>
<p><strong>OUT PFILE_BASIC_INFORMATION</strong>
<em>FileInformation</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of the file, a root directory, and a set of file object
attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the file to be queried. This file specification must be a fully
qualified file specification or the name of a device, unless it is a
file relative to the directory specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the file
specified by the <em>ObjectName</em> field is a file specification
relative to the directory file supplied by this handle.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
<p><em>FileInformation</em> - A variable to receive the basic
information about the file.</p>
</blockquote>
<p>The <strong>NtQueryAttributesFile</strong> service allows the caller
to query the basic information about a file.
<strong>FILE_READ_ATTRIBUTES</strong> access to the target file is
required. This service is equivalent to calling <strong>NtOpenFile,
NtQueryInformationFile</strong> with a file information class of
<em>FileBasicInformation</em>, and <strong>NtClose</strong>. However,
this service is faster because less ring transitions are made.</p>
<p>The information that is returned in the <em>FileInformation</em>
buffer is defined by the following structure:</p>
<p>typedef struct _FILE_BASIC_INFORMATION {</p>
<blockquote>
<p>LARGE_INTEGER CreationTime;</p>
<p>LARGE_INTEGER LastAccessTime;</p>
<p>LARGE_INTEGER LastWriteTime;</p>
<p>LARGE_INTEGER ChangeTime;</p>
<p>ULONG FileAttributes;</p>
</blockquote>
<p>} FILE_BASIC_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>CreationTime</strong> Date/time that the file was created</p>
<p><strong>LastAccessTime</strong> Date/time that the file was last
accessed</p>
<p><strong>LastWriteTime</strong> Date/time that the file was last
written</p>
<p><strong>ChangeTime</strong> Date/time that the file was last
changed</p>
<p><strong>FileAttributes</strong> Attributes of the file</p>
<p>All dates and times are specified in the standard <strong>Windows
NT</strong> system time format.</p>
<p>The file attributes field can be a combination of the following
values:</p>
<p><strong>FILE_ATTRIBUTE_NORMAL</strong></p>
<p><strong>FILE_ATTRIBUTE_READONLY</strong></p>
<p><strong>FILE_ATTRIBUTE_HIDDEN</strong></p>
<p><strong>FILE_ATTRIBUTE_SYSTEM</strong></p>
<p><strong>FILE_ATTRIBUTE_ARCHIVE</strong></p>
<p><strong>FILE_ATTRIBUTE_TEMPORARY</strong></p>
<p><strong>FILE_ATTRIBUTE_COMPRESSED</strong></p>
<p><strong>FILE_ATTRIBUTE_OFFLINE</strong></p>
<h2 id="io-completion-objects">I/O Completion Objects</h2>
<p>This section describes the creation and use of completion
objects.</p>
<h3 id="creatingopening-io-completion-objects">Creating/Opening I/O
Completion Objects</h3>
<p>When a user wishes to synchronize the completion of I/O through the
use of completion objects, he must first create or open an I/O
completion object. Creating or opening a completion object causes the
system to return a handle to the specified object.</p>
<p>I/O completion object handles are closed via the generic
<strong>NtClose</strong> service. This service is discussed elsewhere in
the <strong>Windows NT</strong> documentation. It should be noted that,
just like all other system objects, a completion object is not actually
deleted until all of the valid handles to it are closed and no
referenced pointers remain.</p>
<p>The user APIs that support creating and opening completion objects
are as follows:</p>
<blockquote>
<p><strong>NtCreateIoCompletion</strong> - Create or open an I/O
completion object and return a handle.</p>
<p><strong>NtOpenIoCompletion</strong> - Open an existing I/O completion
object and return a handle.</p>
</blockquote>
<h4 id="createopen-io-completion-objects">Create/Open I/O Completion
Objects</h4>
<p>An I/O completion object can be created or opened using the
<strong>NtCreateIoCompletion</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtCreateIoCompletion(</strong></p>
<blockquote>
<p><strong>OUT PHANDLE</strong> <em>IoCompletionHandle,</em></p>
<p><strong>IN ACCESS_MASK</strong> <em>DesiredAccess,</em></p>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes</em>
<strong>OPTIONAL</strong><em>,</em></p>
<p><strong>IN ULONG</strong> <em>Count</em>
<strong>OPTIONAL</strong></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>IoCompletionHandle</em> - A pointer to a variable that receives
the I/O completion object handle value.</p>
<p><em>DesiredAccess</em> - Specifies the type of access that the caller
requires to the completion object.</p>
<p><strong><u>DesiredAccess Flags</u></strong></p>
<p><em>SYNCHRONIZE</em> - The completion object handle may be
waited.</p>
<p><em>IO_COMPLETION_QUERY_STATE</em> - The completion object may be
queried.</p>
<p><em>IO_COMPLETION_MODIFY_STATE</em> - The completion object may be
modified.</p>
<p>The three following values are the generic access types that the
caller may request. The mapping to specific access rights is given for
each:</p>
<p><em>GENERIC_READ</em> - Maps to <em>STANDARD_RIGHTS_READ</em> and
<em>IO_COMPLETION_QUERY_STATE</em>.</p>
<p><em>GENERIC_WRITE</em> - Maps to <em>STANDARD_RIGHTS_WRITE</em> and
<em>IO_COMPLETION_MODIFY_STATE</em>.</p>
<p><em>GENERIC_EXECUTE</em> - Maps to <em>STANDARD_RIGHTS_EXECUTE</em>
and <em>SYNCHRONIZE</em>.</p>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of completion object, a root directory, a security descriptor,
a quality of service descriptor, and a set of completion object
attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the completion object to be created or opened. This object name
specification must be a fully qualified path, unless it is relative to
the object directory specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the completion
object specified by the <em>ObjectName</em> field is a path
specification relative to the directory object supplied by this
handle.</p>
<p><strong>PSECURITY_DESCRIPTOR</strong> <em>SecurityDescriptor</em> -
Optionally specifies the security descriptor that should be applied to
the I/O completion object. The ACLs specified by the security descriptor
are only applied to the object if it is created. If not supplied and the
completion object is created, then the ACL placed on the completion
object is formed from a combination of the ACL on the parent directory
of the object and the current default ACL for the creating process.</p>
<p><strong>PSECURITY_QUALITY_OF_SERVICE</strong>
<em>SecurityQualityOfService</em> - Specifies the access a server should
be given to the client's security context. This field is only used when
a connection to a protected server is established. It allows the caller
to control which parts of his security context are made available to the
server and whether or not the server may impersonate the caller.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_INHERIT</em> - Indicates that the handle to the I/O
completion object is to be inherited by the new process when an
<strong>NtCreateProcess</strong> operation is performed to create a new
process.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
<p><em>OBJ_EXCLUSIVE</em> - Indicates that the I/O completion object is
to be created such that no other opens to the object may be
performed.</p>
<p><em>OBJ_OPENIF</em> - Indicates that if the I/O completion object
already exists then it is to be opened; otherwise it is to be
created.</p>
<p><em>Count</em> - An optional value that supplies the maximum number
of threads that should be concurrently active. If this parameter is not
specified, then the number of processors is used.</p>
</blockquote>
<p>The <strong>NtCreateIoCompletion</strong> service either causes a new
I/O completion object to be created, or it opens an existing completion
object. The action taken is dependent on the name of the object being
opened, and whether the object already existed, and the value of the
<em>OBJ_OPENIF ObjectAttributes</em> flag. If the object is created,
then the maximum target concurrent thread count is set to the value
specified by the <em>Count</em> parameter. A handle to the I/O
completion object with the <em>DesiredAccess</em> is returned.</p>
<p>Once the caller has established a handle to an I/O completion object,
he can then associate the completion object with a file, via the
<strong>NtSetInformationFile</strong> system service. As each request
for the file is completed, the I/O system stores a completion message in
the I/O completion object.</p>
<p>Each completion message consists of a caller-determined key
identifying the target file, a caller-supplied
<em>CompletionContext</em> pointer, which was passed as
<em>ApcContext</em> to the asynchronous <strong>Nt...File</strong>
service when the request was originally issued, and a pointer to the
returned I/O status block for the completed request.</p>
<h4 id="open-io-completion-objects">Open I/O Completion Objects</h4>
<p>An I/O completion object can be opened using the
<strong>NtOpenIoCompletion</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtOpenIoCompletion(</strong></p>
<blockquote>
<p><strong>OUT PHANDLE</strong> <em>IoCompletionHandle</em>,</p>
<p><strong>IN ACCESS_MASK</strong> <em>DesiredAccess</em>,</p>
<p><strong>IN POBJECT_ATTRIBUTES</strong> <em>ObjectAttributes</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>IoCompletionHandle</em> - A pointer to a variable that receives
the I/O completion object handle value.</p>
<p><em>DesiredAccess</em> - Specifies the type of access that the caller
requires to the completion object.</p>
<p><strong><u>DesiredAccess Flags</u></strong></p>
<p><em>SYNCHRONIZE</em> - The completion object handle may be
waited.</p>
<p><em>IO_COMPLETION_QUERY_STATE</em> - The completion object may be
queried.</p>
<p><em>IO_COMPLETION_MODIFY_STATE</em> - The completion object may be
modified.</p>
<p>The three following values are the generic access types that the
caller may request. The mapping to specific access rights is given for
each:</p>
<p><em>GENERIC_READ</em> - Maps to <em>STANDARD_RIGHTS_READ</em> and
<em>IO_COMPLETION_QUERY_STATE</em>.</p>
<p><em>GENERIC_WRITE</em> - Maps to <em>STANDARD_RIGHTS_WRITE</em> and
<em>IO_COMPLETION_MODIFY_STATE</em>.</p>
<p><em>GENERIC_EXECUTE</em> - Maps to <em>STANDARD_RIGHTS_EXECUTE</em>
and <em>SYNCHRONIZE</em>.</p>
<p><em>ObjectAttributes</em> - A pointer to a structure that specifies
the name of completion object, a root directory, a security descriptor,
a quality of service descriptor, and a set of completion object
attribute flags.</p>
<p><strong><u>ObjectAttributes Structure</u></strong></p>
<p><strong>ULONG</strong> <em>Length</em> - Specifies the length of the
object attributes structure. This field must be equal to the size of an
<em>OBJECT_ATTRIBUTES</em> structure.</p>
<p><strong>PUNICODE_STRING</strong> <em>ObjectName</em> - The name of
the completion object to be opened. This object name specification must
be a fully qualified path, unless it is relative to the object directory
specified by the next field.</p>
<p><strong>HANDLE</strong> <em>RootDirectory</em> - Optionally specifies
a handle to a directory. If specified, then the name of the completion
object specified by the <em>ObjectName</em> field is a path
specification relative to the directory object supplied by this
handle.</p>
<p><strong>ULONG</strong> <em>Attributes</em> - A set of flags that
controls the file object attributes.</p>
<p><em>OBJ_INHERIT</em> - Indicates that the handle to the I/O
completion object is to be inherited by the new process when an
<strong>NtCreateProcess</strong> operation is performed to create a new
process.</p>
<p><em>OBJ_CASE_INSENSITIVE</em> - Indicates that the name lookup should
ignore the case of <em>ObjectName</em> rather than performing an exact
match search.</p>
</blockquote>
<p>The <strong>NtOpenIoCompletion</strong> service opens an existing I/O
completion object and returns a handle to it through the
<em>IoCompletionHandle</em> parameter.</p>
<p>As with the <strong>NtCreateIoCompletion</strong> service, once the
caller has established a handle to an I/O completion object, he can then
associate the completion object with a file, via the
<strong>NtSetInformationFile</strong> system service. As each request
for the file is completed, the I/O system stores a completion message in
the I/O completion object.</p>
<p>Each completion message consists of a caller-determined key
identifying the target file, a caller-supplied
<em>CompletionContext</em> pointer, which was passed as
<em>ApcContext</em> to the asynchronous <strong>Nt...File</strong>
service when the request was originally issued, and a pointer to the
returned I/O status block for the completed request.</p>
<h3 id="operating-on-io-completion-objects">Operating on I/O Completion
Objects</h3>
<p>This section presents those services that manipulate I/O completion
objects. The APIs that support operations on I/O completion objects are
as follows:</p>
<blockquote>
<p><strong>NtQueryIoCompletion</strong> - Query the state of an I/O
completion object.</p>
<p><strong>NtSetIoCompletion</strong> - Inserts a message onto an I/O
completion object.</p>
<p><strong>NtRemoveIoCompletion</strong> - Removes an entry from an I/O
completion object.</p>
</blockquote>
<h4 id="querying-completion-objects">Querying Completion Objects</h4>
<p>The state of an I/O completion object can be queried using the
<strong>NtQueryIoCompletion</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtQueryIoCompletion(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>IoCompletionHandle</em>,</p>
<p><strong>IN IO_COMPLETION_INFORMATION_CLASS</strong>
IoCompletionInformationClass,</p>
<p><strong>OUT PVOID</strong> <em>IoCompletionInformation</em>,</p>
<p><strong>IN ULONG</strong> <em>IoCompletionInformationLength</em>,</p>
<p><strong>OUT PULONG</strong> <em>ReturnLength</em>
<strong>OPTIONAL</strong></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>IoCompletionHandle</em> - Supplies a handle to an open I/O
completion object to be queried.</p>
<p><em>IoCompletionInformationClass</em> - Specifies the type of
information that should be returned about the I/O completion object. The
information returned in the <em>IoCompletionInformation</em> buffer is
defined by the following type codes:</p>
<p><strong><u>IoCompletionInformationClass Values</u></strong></p>
<p><em>IoCompletionBasicInformation</em> - Returns basic information
about the specified I/O completion object.
<strong>IO_COMPLETION_QUERY_STATE</strong> access to the object is
required.</p>
<p><em>IoCompletionInformation</em> - A pointer to a buffer to receive
the desired information about the I/O completion object. The contents of
this buffer are defined by the <em>IoCompletionInformationClass</em>
parameter described above.</p>
<p><em>IoCompletionInformationLength</em> - The length of the
<em>IoCompletionInformation</em> buffer in bytes.</p>
<p><em>ReturnLength</em> - An optional pointer to a variable to receive
the actual number of bytes of information returned in the
<em>IoCompletionInformation</em> buffer.</p>
</blockquote>
<p>The <strong>NtQueryIoCompletion</strong> service returns information
about the specified I/O completion object. The information in the buffer
is defined by the following type codes and structures.</p>
<p><strong><u>IoCompletionInformation Format by I/O Completion
Information Class</u></strong></p>
<p><em>IoCompletionBasicInformation</em> - Data type is
<em>IO_COMPLETION_BASIC_INFORMATION</em>.</p>
<blockquote>
<p>typedef struct _IO_COMPLETION_BASIC_INFORMATION {</p>
<p>LONG Depth;</p>
<p>} IO_COMPLETION_BASIC_INFORMATION;</p>
<p><strong><u>Field Description</u></strong></p>
<p><strong>Depth</strong> Depth, in messages, of the I/O completion
object</p>
<p><strong>IO_COMPLETION_QUERY_STATE</strong> access to the I/O
completion object is required to obtain this information.</p>
</blockquote>
<p>Once the information about the object has been returned, the caller
can determine how much information was actually returned by examining
the variable passed in as the <em>ReturnLength</em> parameter, if one
was passed.</p>
<h4 id="setting-completion-objects">Setting Completion Objects</h4>
<p>A completion message can be manually queued to an I/O completion
object using the <strong>NtSetIoCompletion</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtSetIoCompletion(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>IoCompletionHandle</em>,</p>
<p><strong>IN ULONG</strong> <em>KeyContext</em>,</p>
<p><strong>IN PVOID</strong> <em>ApcContext</em>,</p>
<p><strong>IN NTSTATUS</strong> <em>IoStatus</em>,</p>
<p><strong>IN ULONG</strong> <em>IoStatusInformation</em></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters<strong>:</strong></u></p>
<blockquote>
<p><em>IoCompletionHandle</em> - A handle to the I/O completion
port.</p>
<p><em>KeyContext</em> - Supplies the key contex that is returned during
a call to <strong>NtRemoveIoCompletion</strong>.</p>
<p><em>ApcContext</em> - Supplies the APC context that is returned
during a call to <strong>NtRemoveIoCompletion</strong>.</p>
<p><em>IoStatus</em> - Supplies the status data that will be returned in
the <em>Status</em> field of the I/O status block during a call to
<strong>NtRemoveIoCompletion</strong>.</p>
<p><em>IoStatusInformation</em> - Supplies the information data that
will be returned in the <em>Information</em> field of the I/O status
block during a call to <strong>NtRemoveIoCompletion</strong>.</p>
</blockquote>
<p>The <strong>NtSetIoCompletion</strong> service allows the caller to
insert an I/O completion message into the completion object manually.
This allows threads that are waiting on messages to arrive to be
awakened to deal with a particular work item posted by the caller. Note
that no I/O was actually performed to cause the completion message to be
read by the remover of the item.</p>
<h4 id="removing-messages-from-completion-objects">Removing Messages
from Completion Objects</h4>
<p>An I/O completion message can be removed from an I/O completion
object using the <strong>NtRemoveIoCompletion</strong> service:</p>
<p><strong>NTSTATUS</strong></p>
<p><strong>NtRemoveIoCompletion(</strong></p>
<blockquote>
<p><strong>IN HANDLE</strong> <em>IoCompletionHandle</em>,</p>
<p><strong>OUT PVOID</strong> <em>*KeyContext</em>,</p>
<p><strong>OUT PVOID</strong> *<em>ApcContext</em>,</p>
<p><strong>OUT PIO_STATUS_BLOCK</strong> <em>IoStatusBlock</em>,</p>
<p><strong>IN PLARGE_INTEGER</strong> <em>Timeout</em>
<strong>OPTIONAL</strong></p>
<p><strong>);</strong></p>
</blockquote>
<p><u>Parameters:</u></p>
<blockquote>
<p><em>IoCompletionHandle</em> - A handle to the I/O completion
port.</p>
<p><em>KeyContext</em> - Supplies a pointer to a variable to receive the
key contex that was specified when the I/O completion object was
associated with a file object.</p>
<p><em>ApcContext</em> - Supplies a pointer to a variable to receive the
context that was specified when the I/O was issued. This value was
passed in as the <em>ApcContext</em> parameter when the I/O was
queued.</p>
<p><em>IoStatus</em> - Supplies a pointer to a variable that receives
the final I/O completion status from the I/O operation.</p>
<p><em>Timeout</em> - Supplies a pointer to an optional time out
value.</p>
</blockquote>
<p>The <strong>NtRemoveIoCompletion</strong> service removes a single
I/O completion message from the completion object. If an entry is
removed, then the <em>KeyContext, ApcContext,</em> and <em>IoStatus</em>
variables receive the information about the I/O operation that was
completed. The <em>Status</em> field of the <em>IoStatus</em> variable
indicates whether or not the I/O operation was successfully completed.
Note that this is separate from the return value from this service,
which indicates whether or not a completion message was successfully
removed from the completion object.</p>
<p>If there are no entries in the completion object, or if there are
already <em>Count</em> threads concurrently ready and/or running due to
other completion messages having been removed, then the calling thread
will wait for another message according to the <em>Timeout</em>
parameter. This parameter is treated in the normal manner of all
time-out values in <em>Windows NT.</em></p>
<h1 id="naming-conventions">Naming Conventions</h1>
<p>Devices in <strong>Windows NT</strong> are named according to a very
simple set of rules. There are three general rules:</p>
<blockquote>
<p>1) If there can only be one device of the specified type in the
system, such as the PC subsystem keyboard, then the name of the device
is simply the device type name.</p>
<p>2) If there can be more than one device of the specified type in the
system, such as a floppy, then the name of the device is the device type
name followed by a decimal number that indicates which device of that
type it is.</p>
<p>3) For devices such as disks, which can be partitioned, the name of
the partition is the name of the device followed by <em>\Partition</em>
and a decimal number representing which partition on the disk it is. The
first partition on a disk is called <em>\Partition1</em>. The name that
refers to the entire device for partitioned media is
<em>\Partition0.</em></p>
</blockquote>
<p>For example, the following are valid <strong>Windows NT</strong>
device names.</p>
<blockquote>
<p>o - <em>\Device\Floppy2</em></p>
<p>o - <em>\Device\Harddisk1\Partition3</em></p>
<p>o - <em>\Device\Keyboard</em></p>
<p>o - <em>\Device\Mouse</em></p>
</blockquote>
<p>Note that all of the above device names are in a directory called the
<em>\Device</em> directory. All device names in <strong>Windows
NT</strong> reside in this object directory by convention. Any valid
object directory operations can be used to determine the names of the
devices on the system, provided the caller has the appropriate
privileges and access to the object directory.</p>
<h1 id="appendix-a---time-field-changes">Appendix A - Time Field
Changes</h1>
<p>This section contains a list of those APIs that implicitly change the
various time fields associated with a file.</p>
<h2 id="last-access-time">Last Access Time</h2>
<p>The Last Access Time field for a file is implicitly changed under the
following conditions:</p>
<blockquote>
<p>o - <strong>NtQueryDirectoryFile</strong> - The directory file's time
field is updated.</p>
<p>o - <strong>NtCreateFile</strong> - The file's time field is set if
the file was created.</p>
<p>o - <strong>NtReadFile</strong> - The file's time field is
updated.</p>
</blockquote>
<h2 id="last-modify-time">Last Modify Time</h2>
<blockquote>
<p>o - <strong>NtCreateFile</strong> - If the file was created,
superseded, or overwritten, then the file's time field is updated. If
the file was created or superseded then the parent directory's time
field is also updated.</p>
<p>o - <strong>NtSetInformationFile</strong></p>
<p>- <strong>FileLinkInformation</strong> - The directory file
containing the name of the link's time field is updated.</p>
<p>- <strong>FileDispositionInformation</strong> - The time field of the
directory that contains the file is updated.</p>
<p>- <strong>FileRenameInformation</strong> - The old and the new parent
directory file's times are updated.</p>
<p>o - <strong>NtWriteFile</strong> - The file's time field is
updated.</p>
</blockquote>
<h2 id="last-change-time">Last Change Time</h2>
<blockquote>
<p>o - <strong>NtCreateFile</strong> - If the file was created,
superseded, or overwritten, then the file's time field is updated. If
the file was created or superseded then the parent directory's time
field is also updated.</p>
<p>o - <strong>NtSetInformationFile</strong></p>
<p>- <strong>FileLinkInformation</strong> - The time field of both the
file and the directory containing the name of the link are updated.</p>
<p>- <strong>FileDispositionInformation</strong> - The time field of
both the file and the directory containing the file are updated.</p>
<p>- <strong>FileRenameInformation</strong> - The time field of both the
old and the new parent directories are updated.</p>
<p>- <strong>FileAllocationInformation</strong> - The file's time field
is updated.</p>
<p>- <strong>FileEndOfFileInformation</strong> - The file's time field
is updated.</p>
<p>o - <strong>NtWriteFile</strong> - The file's time field is
updated.</p>
<p>o - <strong>NtSetSecurityObject</strong> - The file's time field is
updated.</p>
</blockquote>
<h1 id="revision-history"><br />
Revision History </h1>
<blockquote>
<p>Original Draft 1.0, March 21, 1989</p>
<p>Revision Draft 1.1, March 31, 1989</p>
<p>- Fixed spelling, grammar and numbering problems.</p>
<p>- Incorporated initial review comments.</p>
<p>- Removed all APIs that didn't use file handles.</p>
<p>- Rewrote overview section dealing with file objects.</p>
<p>- Added access right types to services.</p>
<p>- Redesigned <strong>NtCreateFile</strong> service.</p>
<p>- Removed <strong>NtOpenFile</strong> service.</p>
<p>- Revamped <strong>NtQueryDirectoryFile</strong> service.</p>
<p>- Added more types to <strong>NtQueryInformationFile</strong>
service.</p>
<p>- Added more types to <strong>NtSetInformationFile</strong>
service.</p>
<p>- Performed general fixup on most other services.</p>
<p>- Added description of DISPATCH_LEVEL driver context.</p>
<p>- Changed device work queues to device queues.</p>
<p>- Redesigned communication region protocol.</p>
<p>- Planned section on volume verification.</p>
<p>Revision Draft 1.2, May 12, 1989</p>
<p>- Allow setting of owner in
<strong>NtSetInformationFile.</strong></p>
<p>- Removed device info from
<strong>NtQueryFsInformationFile.</strong></p>
<p>- Changed <strong>NtQueryFsInformationFile</strong> to
<strong>QueryVolume</strong>.</p>
<p>- Changed <strong>NtSetFsInformationFile</strong> to
<strong>SetVolume</strong>.</p>
<p>- Added ChangeTime to appropriate structures.</p>
<p>- Added I/O provided time-out functions.</p>
<p>- Remove mount entry point from file systems.</p>
<p>- Fleshed out section on volume verification.</p>
<p>- Wrote section on error logging and handling.</p>
<p>- Wrote section on naming conventions.</p>
<p>- Added "subsystem input" section for terminals.</p>
<p>- Wrote section on network service description.</p>
<p>- Added directory access options.</p>
<p>- Fixed access type names.</p>
<p>- Make all byte offsets block/byte offsets.</p>
<p>o Read pointer</p>
<p>o Write pointer</p>
<p>o File allocation size</p>
<p>o End of file marker</p>
<p>- Add new security access types.</p>
<p>- Flesh out Miscellaneous I/O APIs.</p>
<p>- Change FILE_READ and _WRITE back again.</p>
<p>Revision Draft 1.3, October 9, 1989</p>
<p>- Split specification into two separate specs.</p>
<p>- Redo attributes again for security changes (twice).</p>
<p>- Add "names" type to <strong>NtQueryDirectoryFile</strong> since
other API was dropped by object manager.</p>
<p>- Change APC parameter to context and make PVOID.</p>
<p>- Add AscendingDirectories flag to volume info.</p>
<p>- Make file objects waitable objects.</p>
<p>- Make block/byte values zero-based.</p>
<p>- Add synchronous I/O.</p>
<p>- Only signal file handle if no event specified.</p>
<p>- Fix FILEINFO and FSINFO to be like all other APIs.</p>
<p>- Remove nonsensical directory desired accesses.</p>
<p>- Return actual action in Information on create/open.</p>
<p>- Add FILE_SHARE_ NO_DELETE and NO_RENAME.</p>
<p>- Drop FILE_CREATE_TREE_CONNECTION. Will be service.</p>
<p>- Drop FILE_EXECUTE desired access restrictions.</p>
<p>- Drop FILE_APPEND desired access restrictions.</p>
<p>- Drop or change name of privileges.</p>
<p>- Added time field changes appendix.</p>
<p>Revision Draft 1.4, January 21, 1990</p>
<p>- Added <strong>NtOpenFile</strong> system service.</p>
<p>- Removed <strong>NtQueryAclFile</strong> and
<strong>NtSetAclFile</strong> APIs.</p>
<p>- Removed documentation on FileAclInformation.</p>
<p>- Added <strong>NtLockFile</strong> and <strong>NtUnlockFile</strong>
services again.</p>
<p>- Change most services to have synchronous APIs.</p>
<p>- Redo attributes again for security changes.</p>
<p>- Revamped structures around security, especially for directories and
subdirectories.</p>
<p>- Added EAs to <strong>NtCreateFile</strong>.</p>
<p>- Redo EA APIs and EA structures.</p>
<p>- Added rewind capabilities to EA and directory services.</p>
<p>- Added optional key parameter to <strong>NtReadFile</strong> and
<strong>NtWriteFile</strong>.</p>
<p>- Fixed object attributes structure type name and fields.</p>
<p>- Converted APIs from Block and Byte to LARGE_INTEGER.</p>
<p>- Reversed polarity of shared delete and rename flags.</p>
<p>- Expanded type names out to full names.</p>
<p>- Miscellaneous edits and explanation changes.</p>
<p>Revision Draft 1.5, July 9, 1990</p>
<p>- Add EaListLength parameter to <strong>NtQueryEaFile</strong>.</p>
<p>- Removed FILE_MAPPED_IO option.</p>
<p>- Removed FILE_SHARE_RENAME share access.</p>
<p>- Document file sharing semantics.</p>
<p>- Add FileFsSizeInformation to
<strong>NtQueryVolumeInformationFile</strong>.</p>
<p>- Removed FileFsBiosInformation from
<strong>NtQueryVolumeInformationFile</strong>.</p>
<p>- Add RemovableMedia and SupportsObjects fields for volumes.</p>
<p>- Add FILE_OVERWRITE, FILE_OVERWRITE_IF to
<strong>NtCreateFile</strong>.</p>
<p>- Document directory wildcarding.</p>
<p>- Document deleting a file is last valid I/O operation.</p>
<p>- Add FileAlignmentInformation to
<strong>NtQueryInformationFile</strong>.</p>
<p>- Replace OBJ_OPEN_LINK with FILE_OPEN_LINK.</p>
<p>- Add FILE_TRAVERSE as legal directory access.</p>
<p>- Add FILE_OPEN_UNKNOWN_OBJECT option.</p>
<p>- Add FILE_OPENED_UNKNOWN_OBJECT I/O status block value.</p>
<p>- Replace FILE_DISABLE_CACHING with FILE_NO_INTERMEDIATE_BUFFERING
and add requirement restrictions description.</p>
<p>- Add FILE_COMPLETE_IF_OPLOCKED option to create and open.</p>
<p>- Add FileRemainingNameInformation query information type.</p>
<p>- Explicitly state that locking beyond EOF is permissible.</p>
<p>- Switch fields in FILE_FULL_EA_INFORMATION to keep compatibility
with OS/2.</p>
<p>- Fixed references to IOSB and PIOSB.</p>
<p>- Removed explicit ACL and owner interfaces and converted to the new
security semantics.</p>
<p>- Add ability for synchronous I/O locks to be asynchronous.</p>
<p>- Subsumed <strong>NtSetNewSizeFile</strong> functionality in
<strong>NtSetInformationFile</strong>.</p>
<p>- Removed FileOwnerInformation from
<strong>NtQueryInformationFile</strong>.</p>
<p>- Removed FileOwnerInformation from
<strong>NtSetInformationFile</strong>.</p>
<p>- Removed FILE_OWNER_INFORMATION structure type declaration.</p>
<p>Revision Draft 1.6, July 15, 1993</p>
<p>- Removed outdated "++" notation for subsystems.</p>
<p>- Updated system name from NT OS/2 to Windows NT.</p>
<p>- Removed error ports from all appropriate APIs.</p>
<p>- Added new file attribute definitions for FILE_ATTRIBUTE_TEMPORARY,
FILE_ATTRIBUTE_ATOMIC_WRITE, and FILE_ATTRIBUTE_XACTION_WRITE.</p>
<p>- Removed all vestiges of "unknown objects" and all related
functionality.</p>
<p>- Replaced old style create/open directory manipulation flags (see
next).</p>
<p>- Documented all new Create/Open options:</p>
<p>o FILE_DIRECTORY_FILE</p>
<p>o FILE_NON_DIRECTORY_FILE</p>
<p>o FILE_RANDOM_ACCESS</p>
<p>o FILE_NO_EA_KNOWLEDGE</p>
<p>o FILE_DELETE_ON_CLOSE</p>
<p>o FILE_OPEN_BY_FILE_ID</p>
<p>o FILE_OPEN_FOR_BACKUP_INTENT</p>
<p>- Updated all appropriate CHAR's to WCHAR's in accordance w/Unicode
changes.</p>
<p>- Updated all STRING's to UNICODE_STRING's in accordance w/Unicode
changes.</p>
<p>- Removed source/target process from <strong>NtReadFile</strong> and
<strong>NtWriteFile</strong>.</p>
<p>- Removed <strong>NtReadTerminalFile</strong> API.</p>
<p>- Updated all TIME data types to LARGE_INTEGER's.</p>
<p>- Moved FILE_ATTRIBUTE_DIRECTORY flag into attributes for query
operations.</p>
<p>- Added FileBothDirectoryInformation file information class to
<strong>NtQueryDirectoryFile</strong>.</p>
<p>- Changed Action field of FILE_NOTIFY_INFORMATION to ULONG.</p>
<p>- Added FileAlternateNameInformation to
<strong>NtQueryInformationFile</strong>.</p>
<p>- Added FileStreamInformation to
<strong>NtQueryInformationFile</strong>.</p>
<p>- Changed FileNameInformation to FileRenameInformation for
<strong>NtSetInformationFile</strong>.</p>
<p>- Updated Length parameter to LARGE_INTEGER from ULONG for locking
services.</p>
<p>- Added FileFsDeviceInformation and FileFsAttributeInformation to
<strong>NtQueryVolumeInformation</strong>.</p>
<p>Revision Draft 1.7, May 1, 1995</p>
<p>- Added new FILE_OPEN_TRANSACTED and FILE_RESERVE_OPFILTER
create/open options.</p>
<p>- Removed FILE_ATTRIBUTE_ATOMIC_WRITE and
FILE_ATTRIBUTE_XACTION_WRITE and added FILE_ATTRIBUTE_COMPRESSED and
FILE_ATTRIBUTE_OFFLINE..</p>
<p>- Added new STORAGE_TYPE enumerated type as well as new create/open
option fields for storage types.</p>
<p>- Added values for FILE_NOTIFY_CHANGE_STREAM_NAME,
FILE_NOTIFY_CHANGE_STREAM_SIZE, and FILE_NOTIFY_CHANGE_STREAM_WRITE.</p>
<p>- Added documentation of file system attributes flags, and included
new flags FILE_FILE_COMPRESSED and FILE_VOLUME_IS_COMPRESSED for
compression.</p>
<p>- Added FILE_VIRTUAL_VOLUME device characteristic flag for virtual
volumes.</p>
<p>- Added the following query and set information class information
values and their associated structure type definitions:</p>
<p>o FileCompressionInformation</p>
<p>o FileCopyOnWriteInformation</p>
<p>o FileCompletionInformation</p>
<p>o FileMoveClusterInformation</p>
<p>o FileOleClassIdInformation</p>
<p>o FileOleStateBitsInformation</p>
<p>o FileApplicationExplorableInformation</p>
<p>o FileApplicationExplorableChildrenInformation</p>
<p>o FileObjectIdInformation</p>
<p>o FileOleAllInformation</p>
<p>o FileContentIndexInformation</p>
<p>o FileInheritContentIndexInformation</p>
<p>o FileOleInformation</p>
<p>- Added new <strong>NtQueryOleDirectoryFile</strong> API
description.</p>
<p>- Added new FileOleDirectoryInformation directory information class
and its associated structure type definition.</p>
<p>- Added new directory query information class for OLE files.</p>
<p>- Added query and set volume information class information values and
its associated type definitions for FileFsControlInformation</p>
<p>- Added new <strong>NtQueryQuotaInformationFile</strong> and
<strong>NtSetQuotaInformationFile</strong> API descriptions.</p>
<p>- Added new data structure types (FILE_GET_QUOTA_INFORMATION and
FILE_QUOTA_INFORMATION) for the above services.</p>
<p>- Added new <strong>NtDeleteFile</strong> API description.</p>
<p>- Added new <strong>NtQueryAttributesFile</strong> API
description.</p>
<p>- Added new I/O completion object section for APIs, access rights,
information class values, and data structures.</p>
<p>- Removed old <strong>NtDeviceIoControlFile</strong> and
<strong>NtFsControlFile</strong> appendicies to alleviate concerns that
they weren’t filled in (since they never will be populated).</p>
<p>- Added device types for FILE_DEVICE_BATTERY and
FILE_DEVICE_BUS_EXTENDER.</p>
<p>- Removed POSIX and OS/2 subsystem API implementation sections</p>
</blockquote>
